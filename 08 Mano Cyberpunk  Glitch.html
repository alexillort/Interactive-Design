<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Mano Cyberpunk / Glitch Dinámico</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; } /* Añadido cursor para indicar clic */
        canvas { position: absolute; top: 0; left: 0; transform: scaleX(-1); }
        #background-canvas { z-index: 1; }
        #interaction-canvas { z-index: 2; }
        #input_video { display: none; } 
    </style>
</head>
<body>
    <video id="input_video" autoplay playsinline></video>
    <canvas id="background-canvas"></canvas>
    <canvas id="interaction-canvas"></canvas>

    <script type="module">
        import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const HAND_CONNECTIONS = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [17, 18], [18, 19], [19, 20], [0, 17]];

        const video = document.getElementById("input_video");
        const bgCanvas = document.getElementById("background-canvas");
        const bgCtx = bgCanvas.getContext("2d");
        const intCanvas = document.getElementById("interaction-canvas");
        const intCtx = intCanvas.getContext("2d");
        const drawingUtils = new DrawingUtils(intCtx);
        
        let handLandmarker;

        // --- CAMBIO 1: Variable para activar los puntos una sola vez y manejador de eventos ---
        let showTrackingPoints = false;

        function activateTrackingVisibility() {
            showTrackingPoints = true;
            // Remover los listeners para que solo se active una vez
            window.removeEventListener('click', activateTrackingVisibility);
            window.removeEventListener('touchstart', activateTrackingVisibility);
            document.body.style.cursor = 'default'; // Opcional: cambiar el cursor de nuevo
        }
        window.addEventListener('click', activateTrackingVisibility);
        window.addEventListener('touchstart', activateTrackingVisibility);


        // --- CAMBIO 2: Colores para el efecto Glitch (Rojo y Azul) ---
        // Usamos HSLA para controlar el tono y la opacidad.
        // Hue 0 = Rojo, Hue 240 = Azul
        const glitchColors = [
            'hsla(0, 100%, 60%, 0.2)',  // Rojo
            'hsla(240, 100%, 60%, 0.2)' // Azul
        ];
        const pointColors = [
            'rgba(255, 0, 0, 0.8)', // Rojo más sólido para puntos
            'rgba(0, 0, 255, 0.8)'  // Azul más sólido para puntos
        ];


        // Función para calcular la silueta de la mano (Convex Hull)
        function getHandHull(points) {
            points.sort((a, b) => a.x - b.x || a.y - b.y);
            const lower = [];
            for (const p of points) {
                while (lower.length >= 2 && crossProduct(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                    lower.pop();
                }
                lower.push(p);
            }
            const upper = [];
            for (let i = points.length - 1; i >= 0; i--) {
                const p = points[i];
                while (upper.length >= 2 && crossProduct(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                    upper.pop();
                }
                upper.push(p);
            }
            return lower.slice(0, -1).concat(upper.slice(0, -1));
        }
        function crossProduct(o, a, b) {
            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
        }

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, { 
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2 
            });
            startCamera();
        }
        createHandLandmarker();

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    [bgCanvas, intCanvas].forEach(c => { c.width = video.videoWidth; c.height = video.videoHeight; });
                    const scaleFactor = Math.min(window.innerWidth / video.videoWidth, window.innerHeight / video.videoHeight);
                    const newWidth = video.videoWidth * scaleFactor;
                    const newHeight = video.videoHeight * scaleFactor;
                    const newLeft = (window.innerWidth - newWidth) / 2;
                    const newTop = (window.innerHeight - newHeight) / 2;
                    [bgCanvas, intCanvas].forEach(c => { c.style.width = `${newWidth}px`; c.style.height = `${newHeight}px`; c.style.left = `${newLeft}px`; c.style.top = `${newTop}px`; });
                    animate();
                });
            });
        }

        function animate() {
            bgCtx.drawImage(video, 0, 0, bgCanvas.width, bgCanvas.height);
            intCtx.clearRect(0, 0, intCanvas.width, intCanvas.height);

            // --- CAMBIO 3: Selecciona el color actual basado en el tiempo ---
            const colorIndex = Math.floor(performance.now() / 200) % glitchColors.length; // Cambia cada 200ms
            const currentColor = glitchColors[colorIndex];
            const currentPointColor = pointColors[colorIndex];

            if (handLandmarker) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                if (results.landmarks && results.landmarks.length > 0) {
                    for (const landmarks of results.landmarks) {
                        const points = landmarks.map(p => ({ x: p.x * intCanvas.width, y: p.y * intCanvas.height }));
                        const hull = getHandHull(points);

                        // 1. Dibuja la silueta y la usa como máscara
                        intCtx.save();
                        intCtx.beginPath();
                        intCtx.moveTo(hull[0].x, hull[0].y);
                        for (let i = 1; i < hull.length; i++) {
                            intCtx.lineTo(hull[i].x, hull[i].y);
                        }
                        intCtx.closePath();
                        intCtx.clip();

                        // 2. Dibuja el efecto Glitch dentro de la máscara
                        for (let i = 0; i < 50; i++) {
                            const y = Math.random() * intCanvas.height;
                            const h = Math.random() * 20 + 1;
                            const xOffset = (Math.random() - 0.5) * 40;

                            intCtx.drawImage(bgCanvas, 0, y, intCanvas.width, h, xOffset, y, intCanvas.width, h);
                        }

                        // 3. Aplica un tinte de color glitch
                        intCtx.fillStyle = currentColor; // Usa el color que cambia
                        intCtx.fillRect(0, 0, intCanvas.width, intCanvas.height);
                        
                        intCtx.restore();

                        // --- CAMBIO 4: Dibuja el esqueleto y los puntos solo si 'showTrackingPoints' es true ---
                        if (showTrackingPoints) {
                            drawingUtils.drawConnectors(landmarks, HAND_CONNECTIONS, { color: currentPointColor, lineWidth: 2 }); // Color que cambia
                            drawingUtils.drawLandmarks(landmarks, { color: 'rgba(255, 255, 255, 0.8)', radius: 3, fillColor: currentPointColor }); // Puntos blancos con color de relleno que cambia
                        }
                    }
                }
            }
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
