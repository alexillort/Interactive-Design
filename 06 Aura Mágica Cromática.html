<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Aura Mágica Cromática</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; }
        
        /* --- CAMBIO 1 (PROPORCIÓN): Estilo del Canvas --- */
        /* Usamos la misma lógica del script de LEGO para posicionar el canvas */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            /* El transform de scaleX(-1) se aplicará en p5.js para el modo espejo */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        let handLandmarker;
        let lastVideoTime = -1;
        let detections = null;

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, { 
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2 
            });
        }
        
        main();

        async function main() {
            await createHandLandmarker();
            new p5(sketch);
        }

        const sketch = (p) => {
            let video;
            let auraLayer;
            let showTrackingPoints = false;
            let canvasIniciado = false;

            p.setup = () => {
                // No creamos el canvas aquí, esperamos al video
                video = p.createCapture(p.VIDEO);
                video.hide();
            };
            
            p.mousePressed = () => {
                showTrackingPoints = !showTrackingPoints;
            };

            p.draw = () => {
                // --- CAMBIO 2 (PROPORCIÓN): Lógica de inicialización del LEGO code ---
                if (!canvasIniciado && video.width > 0) {
                    // Crea el canvas con el tamaño EXACTO del video
                    p.createCanvas(video.width, video.height);
                    auraLayer = p.createGraphics(p.width, p.height);

                    // --- Lógica de escalado del script de LEGO ---
                    const scaleFactor = p.min(p.windowWidth / video.width, p.windowHeight / video.height);
                    const newWidth = video.width * scaleFactor;
                    const newHeight = video.height * scaleFactor;
                    const newLeft = (p.windowWidth - newWidth) / 2;
                    const newTop = (p.windowHeight - newHeight) / 2;
                    
                    p.canvas.style.width = `${newWidth}px`;
                    p.canvas.style.height = `${newHeight}px`;
                    p.canvas.style.left = `${newLeft}px`;
                    p.canvas.style.top = `${newTop}px`;
                    // --- Fin de la lógica de escalado ---

                    canvasIniciado = true;
                }
                
                if (!canvasIniciado) { p.background(0); return; }

                if (video.elt.readyState === 4 && handLandmarker) {
                    if (video.elt.currentTime !== lastVideoTime) {
                        lastVideoTime = video.elt.currentTime;
                        detections = handLandmarker.detectForVideo(video.elt, Date.now());
                    }
                }
                
                // Dibuja el video
                p.push();
                p.translate(p.width, 0); // Modo espejo
                p.scale(-1, 1);
                p.image(video, 0, 0, p.width, p.height);
                p.pop();

                auraLayer.clear();
                auraLayer.colorMode(p.HSB, 360, 100, 100); 
                auraLayer.noStroke();
                
                if (detections && detections.landmarks) {
                    // --- CAMBIO 3 (COLOR): Un color base que cambia con el tiempo ---
                    const baseHue = (p.frameCount * 0.5) % 360; 

                    detections.landmarks.forEach((landmarks, index) => {
                        // Asigna un color diferente a cada mano (index 0 o 1)
                        // Mano 1: Tonos cálidos (rojo/naranja)
                        // Mano 2: Tonos fríos (cian/azul)
                        const hue = (baseHue + (index * 180)) % 360; 

                        for (const point of landmarks) {
                            auraLayer.fill(hue, 90, 90); // Rellena con el color dinámico por mano
                            auraLayer.ellipse(point.x * p.width, point.y * p.height, 80, 80);
                        }
                    });
                }

                auraLayer.filter(p.BLUR, 30);
                
                // --- CAMBIO 4 (COLOR): Se quita el filtro THRESHOLD ---
                // auraLayer.filter(p.THRESHOLD, 0.2); // Esta línea volvía el aura blanca

                // Dibuja la capa del aura
                p.push();
                p.translate(p.width, 0);
                p.scale(-1, 1);
                p.drawingContext.globalCompositeOperation = 'screen';
                p.image(auraLayer, 0, 0, p.width, p.height);
                p.drawingContext.globalCompositeOperation = 'source-over';
                p.pop();

                // Dibuja los puntos de seguimiento
                if (showTrackingPoints && detections && detections.landmarks) {
                    p.push();
                    p.translate(p.width, 0);
                    p.scale(-1, 1);
                    for (const landmarks of detections.landmarks) {
                        for (const point of landmarks) {
                            p.fill(255);
                            p.noStroke();
                            p.ellipse(point.x * p.width, point.y * p.height, 10, 10);
                        }
                    }
                    p.pop();
                }
            };
        };
    </script>
</body>
</html>
