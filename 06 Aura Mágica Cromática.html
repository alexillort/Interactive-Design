<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Aura Mágica Cromática</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; }
        canvas {
            position: absolute;
            /* top y left se establecerán por JavaScript */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        let handLandmarker;
        let lastVideoTime = -1;
        let detections = null;

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, { 
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2 
            });
        }
        
        main();

        async function main() {
            await createHandLandmarker();
            new p5(sketch);
        }

        const sketch = (p) => {
            let video;
            let auraLayer;
            let showTrackingPoints = false;
            let canvasIniciado = false;

            p.setup = () => {
                video = p.createCapture(p.VIDEO);
                video.hide();
            };
            
            p.mousePressed = () => {
                showTrackingPoints = !showTrackingPoints;
            };

            p.draw = () => {
                // --- ¡CAMBIO CLAVE AQUÍ! ---
                // Se usan las propiedades .elt.videoWidth y .elt.videoHeight
                if (!canvasIniciado && video.elt.videoWidth > 0) {
                    
                    const vidWidth = video.elt.videoWidth;
                    const vidHeight = video.elt.videoHeight;
                    
                    p.createCanvas(vidWidth, vidHeight); // Crea el canvas con la proporción nativa REAL
                    auraLayer = p.createGraphics(vidWidth, vidHeight);

                    // Lógica de escalado del script de LEGO
                    const scaleFactor = p.min(p.windowWidth / vidWidth, p.windowHeight / vidHeight);
                    const newWidth = vidWidth * scaleFactor;
                    const newHeight = vidHeight * scaleFactor;
                    const newLeft = (p.windowWidth - newWidth) / 2;
                    const newTop = (p.windowHeight - newHeight) / 2;
                    
                    p.canvas.style.width = `${newWidth}px`;
                    p.canvas.style.height = `${newHeight}px`;
                    p.canvas.style.left = `${newLeft}px`;
                    p.canvas.style.top = `${newTop}px`;
                    // --- Fin del cambio ---

                    canvasIniciado = true;
                }
                
                if (!canvasIniciado) { p.background(0); return; }

                if (video.elt.readyState === 4 && handLandmarker) {
                    if (video.elt.currentTime !== lastVideoTime) {
                        lastVideoTime = video.elt.currentTime;
                        detections = handLandmarker.detectForVideo(video.elt, Date.now());
                    }
                }
                
                // Dibuja el video
                p.push();
                p.translate(p.width, 0); // Modo espejo
                p.scale(-1, 1);
                p.image(video, 0, 0, p.width, p.height);
                p.pop();

                auraLayer.clear();
                auraLayer.colorMode(p.HSB, 360, 100, 100); 
                auraLayer.noStroke();
                
                if (detections && detections.landmarks) {
                    const baseHue = (p.frameCount * 0.5) % 360; 
                    detections.landmarks.forEach((landmarks, index) => {
                        const hue = (baseHue + (index * 180)) % 360; 
                        for (const point of landmarks) {
                            auraLayer.fill(hue, 90, 90);
                            auraLayer.ellipse(point.x * p.width, point.y * p.height, 80, 80);
                        }
                    });
                }

                auraLayer.filter(p.BLUR, 30);
                
                // Dibuja la capa del aura
                p.push();
                p.translate(p.width, 0);
                p.scale(-1, 1);
                p.drawingContext.globalCompositeOperation = 'screen';
                p.image(auraLayer, 0, 0, p.width, p.height);
                p.drawingContext.globalCompositeOperation = 'source-over';
                p.pop();

                // Dibuja los puntos de seguimiento
                if (showTrackingPoints && detections && detections.landmarks) {
                    p.push();
                    p.translate(p.width, 0);
                    p.scale(-1, 1);
                    for (const landmarks of detections.landmarks) {
                        for (const point of landmarks) {
                            p.fill(255);
                            p.noStroke();
                            p.ellipse(point.x * p.width, point.y * p.height, 10, 10);
                        }
                    }
                    p.pop();
                }
            };
        };
    </script>
</body>
</html>
