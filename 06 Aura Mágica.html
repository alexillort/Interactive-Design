<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Aura Mágica con P5.js</title>
    <style>
        body { margin: 0; overflow: hidden; }
        main { display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #000; cursor: pointer; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
    <main id="main"></main>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        let handLandmarker;
        let lastVideoTime = -1;
        let detections = null;

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, { 
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2 
            });
        }
        
        main();

        async function main() {
            await createHandLandmarker();
            new p5(sketch);
        }

        const sketch = (p) => {
            let video;
            let auraLayer;
            let showTrackingPoints = false;

            p.setup = () => {
                p.createCanvas(1280, 720).parent('main');
                video = p.createCapture(p.VIDEO);
                video.size(p.width, p.height);
                video.hide();

                auraLayer = p.createGraphics(p.width, p.height);
                // La configuración inicial del modo de color se moverá al bucle draw()
            };
            
            p.mousePressed = () => {
                showTrackingPoints = !showTrackingPoints;
            };

            p.draw = () => {
                if (video.elt.readyState === 4 && handLandmarker) {
                    if (video.elt.currentTime !== lastVideoTime) {
                        lastVideoTime = video.elt.currentTime;
                        detections = handLandmarker.detectForVideo(video.elt, Date.now());
                    }
                }
                
                p.push();
                p.translate(p.width, 0);
                p.scale(-1, 1);
                p.image(video, 0, 0, p.width, p.height);
                p.pop();

                auraLayer.clear();

                // --- CORRECCIÓN CLAVE ---
                // Se debe establecer el modo de color en CADA fotograma,
                // porque la función .clear() lo resetea al modo RGB por defecto.
                auraLayer.colorMode(p.HSB, 360, 100, 100); 
                
                auraLayer.noStroke();
                
                if (detections && detections.landmarks) {
                    for (const landmarks of detections.landmarks) {
                        const hue = (p.frameCount * 0.5) % 360; 

                        for (const point of landmarks) {
                            auraLayer.fill(hue, 90, 80);
                            auraLayer.ellipse(point.x * p.width, point.y * p.height, 80, 80);
                        }
                    }
                }

                auraLayer.filter(p.BLUR, 30);
                auraLayer.filter(p.THRESHOLD, 0.2);

                p.push();
                p.translate(p.width, 0);
                p.scale(-1, 1);
                p.drawingContext.globalCompositeOperation = 'screen';
                p.image(auraLayer, 0, 0);
                p.drawingContext.globalCompositeOperation = 'source-over';
                p.pop();

                if (showTrackingPoints && detections && detections.landmarks) {
                    p.push();
                    p.translate(p.width, 0);
                    p.scale(-1, 1);
                    for (const landmarks of detections.landmarks) {
                        for (const point of landmarks) {
                            p.fill(255);
                            p.noStroke();
                            p.ellipse(point.x * p.width, point.y * p.height, 10, 10);
                        }
                    }
                    p.pop();
                }
            };
        };
    </script>
</body>
</html>
