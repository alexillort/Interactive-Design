<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Escultor de Nebulosas 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #input_video { display: none; transform: scaleX(-1); }
        #info {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-family: monospace; font-size: 24px;
            text-shadow: 2px 2px 4px #000; z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">Haz clic para iniciar</div>
    <video id="input_video" autoplay playsinline></video>
    <div id="container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        let handLandmarker, scene, camera, renderer, composer;
        const video = document.getElementById("input_video");
        const container = document.getElementById("container");
        const infoDiv = document.getElementById("info");

        // --- Configuración de Audio (Tone.js) ---
        let audioInitialized = false;
        let windSynth, blastSynth;

        function setupWebAudio() {
            if (audioInitialized) return;
            Tone.start();
            
            windSynth = new Tone.NoiseSynth({
                noise: { type: "pink" },
                envelope: { attack: 0.1, decay: 0.2, sustain: 1 },
                volume: -Infinity
            }).toDestination();
            
            blastSynth = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 2,
                envelope: { attack: 0.001, decay: 0.3, sustain: 0 },
                volume: -5
            }).toDestination();
            
            audioInitialized = true;
            infoDiv.style.display = 'none';
        }
        document.body.addEventListener('click', setupWebAudio, { once: true });

        // --- Configuración de 3D ---
        const GESTURE_THRESHOLD = 0.18;
        const NUM_PARTICLES = 10000;
        const FIELD_RADIUS = 30;
        
        const ATTRACTION_FORCE = 0.05;
        const REPEL_FORCE = 0.5;
        const PARTICLE_DAMPING = 0.96;
        
        // --- Nuevos valores para el control del Bloom ---
        const BLOOM_MAX_STRENGTH = 3.0; // Fuerza máxima del bloom
        const BLOOM_MIN_STRENGTH = 0.5; // Fuerza mínima (base)
        const BLOOM_LERP_FACTOR = 0.1; // Factor de interpolación para la suavidad del bloom

        let particleSystem;
        let particles = [];
        let handAttractors = [new THREE.Vector3(), new THREE.Vector3()];
        let wasFist = [false, false];

        let currentBloomStrength = BLOOM_MIN_STRENGTH; // Estado actual del bloom

        // Clase para gestionar la física de cada partícula
        class Particle {
            constructor(index, basePos) {
                this.index = index;
                this.pos = basePos.clone();
                this.basePos = basePos.clone();
                this.vel = new THREE.Vector3();
            }
            
            update(damping, handPositions, fistStates) {
                let totalForce = new THREE.Vector3();
                
                totalForce.add(this.basePos.clone().sub(this.pos).multiplyScalar(0.0005));

                handPositions.forEach((handPos, handIndex) => {
                    if (handPos) {
                        const dist = this.pos.distanceTo(handPos);
                        if (dist < FIELD_RADIUS) {
                            const forceDirection = this.pos.clone().sub(handPos).normalize();
                            if (fistStates[handIndex]) {
                                totalForce.add(forceDirection.multiplyScalar(REPEL_FORCE));
                            } else {
                                totalForce.add(forceDirection.multiplyScalar(-ATTRACTION_FORCE));
                            }
                        }
                    }
                });

                this.vel.add(totalForce);
                this.vel.multiplyScalar(damping);
                this.pos.add(this.vel);
            }
        }

        async function setupMediapipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO",
                numHands: 2
            });
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ 
                video: { width: {ideal: 640}, height: {ideal: 480} } 
            }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    video.width = video.videoWidth;
                    video.height = video.videoHeight;
                    setupThreeJS();
                    animate();
                });
            });
        }

        // --- Función para crear la textura de círculo suave ---
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.8, 'rgba(255,255,255,0)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            return new THREE.CanvasTexture(canvas);
        }

        function setupThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: container.appendChild(document.createElement('canvas')) });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            
            const videoTexture = new THREE.VideoTexture(video);
            videoTexture.wrapS = THREE.RepeatWrapping;
            videoTexture.repeat.x = -1; 
            const planeGeo = new THREE.PlaneGeometry(1, 1);
            const planeMat = new THREE.MeshBasicMaterial({ 
                map: videoTexture, 
                color: 0x333333
            });
            const backgroundPlane = new THREE.Mesh(planeGeo, planeMat);
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const planeHeight = 2 * Math.tan(vFOV / 2) * Math.abs(camera.position.z);
            const planeWidth = planeHeight * camera.aspect;
            backgroundPlane.scale.set(planeWidth, planeHeight, 1);
            scene.add(backgroundPlane);

            // --- Campo de Partículas ---
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(NUM_PARTICLES * 3);
            const colors = new Float32Array(NUM_PARTICLES * 3);

            for (let i = 0; i < NUM_PARTICLES; i++) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = FIELD_RADIUS * Math.pow(Math.random(), 1/3);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                particles.push(new Particle(i, new THREE.Vector3(x, y, z)));

                const color = new THREE.Color();
                color.setHSL(0.5 + Math.random() * 0.2, 1.0, 0.5 + Math.random() * 0.3);
                color.toArray(colors, i * 3);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // --- Usar la textura de círculo para las partículas ---
            const particleTexture = createParticleTexture();
            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false,
                sizeAttenuation: true,
                map: particleTexture // <-- ¡Aquí aplicamos la textura!
            });
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            // Post-procesado (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = currentBloomStrength; // Inicializamos con la fuerza base
            bloomPass.radius = 0.8;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function mapTo3DWorld(point) {
            const z = 0;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const height = 2 * Math.tan(vFOV / 2) * Math.abs(camera.position.z - z);
            const width = height * camera.aspect;
            const vec = new THREE.Vector3();
            vec.x = (1.0 - point.x - 0.5) * width; 
            vec.y = -(point.y - 0.5) * height;
            vec.z = (point.z * -1) * 30; 
            return vec;
        }

        function detectGesture(landmarks) {
            const palm = landmarks[0];
            let totalDistance = 0;
            const FINGER_TIPS = [4, 8, 12, 16, 20];
            for (const tipIndex of FINGER_TIPS) {
                totalDistance += Math.hypot(landmarks[tipIndex].x - palm.x, landmarks[tipIndex].y - palm.y);
            }
            return (totalDistance / FINGER_TIPS.length) < GESTURE_THRESHOLD;
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const results = handLandmarker?.detectForVideo(video, performance.now());
            
            let handPositions = [null, null];
            let fistStates = [false, false];
            let handsDetected = 0;
            let targetBloomStrength = BLOOM_MIN_STRENGTH; // El bloom objetivo para este frame

            if (results?.handedness) {
                results.handedness.forEach((hand, handIndex) => {
                    handsDetected++;
                    const landmarks = results.landmarks[handIndex];
                    const palmWorldPos = mapTo3DWorld(landmarks[9]);
                    handPositions[handIndex] = palmWorldPos;
                    
                    const isFist = detectGesture(landmarks);
                    fistStates[handIndex] = isFist;

                    if (isFist && !wasFist[handIndex]) {
                        if(audioInitialized) blastSynth.triggerAttackRelease("C2", "0.2");
                        targetBloomStrength = BLOOM_MAX_STRENGTH; // Aumentar bloom al cerrar el puño
                    }
                    wasFist[handIndex] = isFist;
                });
            }
            if(handsDetected === 0) wasFist = [false, false];

            // --- Actualizar física de partículas ---
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < NUM_PARTICLES; i++) {
                particles[i].update(PARTICLE_DAMPING, handPositions, fistStates);
                particles[i].pos.toArray(positions, i * 3);
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;

            // --- Suavizar la transición del Bloom ---
            currentBloomStrength = THREE.MathUtils.lerp(currentBloomStrength, targetBloomStrength, BLOOM_LERP_FACTOR);
            composer.passes[1].strength = currentBloomStrength;

            // --- Actualizar Audio ---
            if (audioInitialized) {
                if (handsDetected > 0) {
                    let totalFist = fistStates.reduce((acc, val) => acc + (val ? 1 : 0), 0);
                    let totalOpen = handsDetected - totalFist;
                    
                    if (totalOpen > 0) {
                        windSynth.volume.rampTo(-20, 0.1);
                    } else {
                        windSynth.volume.rampTo(-Infinity, 0.1);
                    }
                } else {
                    windSynth.volume.rampTo(-Infinity, 0.5);
                }
            }
            
            composer.render();
        }

        setupMediapipe();
    </script>
</body>
</html>
