<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Nebulosa Interactiva 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #render-canvas { position: absolute; top: 0; left: 0; }
        #input_video { transform: scaleX(-1); display: none; }
    </style>
</head>
<body>
    <video id="input_video" autoplay playsinline></video>
    <canvas id="render-canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const video = document.getElementById("input_video");
        let handLandmarker;
        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });
            startCamera();
        }
        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    init();
                    animate();
                });
            });
        }
        createHandLandmarker();

        let scene, camera, renderer, composer, particles, particleVelocities;
        const handAttractors = [new THREE.Vector3(), new THREE.Vector3()];
        let handMarkers = [];

        const NUM_PARTICLES = 5000;
        const ATTRACTION_FORCE = 1.5;
        const DAMPING = 0.98;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 150;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('render-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;

            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(NUM_PARTICLES * 3);
            particleVelocities = new Float32Array(NUM_PARTICLES * 3);
            const colors = new Float32Array(NUM_PARTICLES * 3);
            const color1 = new THREE.Color("#ff00ff");
            const color2 = new THREE.Color("#00ffff");
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const i3 = i * 3;
                particlePositions[i3] = (Math.random() - 0.5) * 400;
                particlePositions[i3 + 1] = (Math.random() - 0.5) * 400;
                particlePositions[i3 + 2] = (Math.random() - 0.5) * 400;
                const mixedColor = color1.clone().lerp(color2, Math.random());
                colors[i3] = mixedColor.r;
                colors[i3 + 1] = mixedColor.g;
                colors[i3 + 2] = mixedColor.b;
            }
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.5, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8
            });
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            const markerGeometry = new THREE.SphereGeometry(2, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({
                color: 0x99ff00, // Cambiado a un verde lima para mejor visibilidad
                toneMapped: false
            });
            for (let i = 0; i < 2; i++) {
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(0, 0, -1000);
                scene.add(marker);
                handMarkers.push(marker);
            }

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- NUEVA FUNCIÓN PARA CORREGIR EL DESFASE ---
        // Convierte las coordenadas de MediaPipe (0 a 1) a coordenadas del mundo 3D
        function mapHandTo3DWorld(point, targetZ) {
            // Calcula el alto y ancho visible en el plano Z objetivo
            const vFOV = THREE.MathUtils.degToRad(camera.fov); // Campo de visión vertical a radianes
            const visibleHeight = 2 * Math.tan(vFOV / 2) * Math.abs(targetZ - camera.position.z);
            const visibleWidth = visibleHeight * camera.aspect;

            // Mapea las coordenadas normalizadas a las dimensiones del mundo 3D
            // Se invierten para que coincidan con el video espejado
            const worldX = -(point.x - 0.5) * visibleWidth;
            const worldY = -(point.y - 0.5) * visibleHeight;

            return new THREE.Vector3(worldX, worldY, targetZ);
        }


        function animate() {
            requestAnimationFrame(animate);
            const results = handLandmarker?.detectForVideo(video, performance.now());
            
            handAttractors.forEach(attractor => attractor.set(0, 0, -1000));
            handMarkers.forEach(marker => marker.position.set(0, 0, -1000));

            if (results?.landmarks) {
                results.landmarks.forEach((landmarks, index) => {
                    const palm = landmarks[9];
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                    const zPos = THREE.MathUtils.mapLinear(pinchDist, 0.2, 0.02, -100, 100);

                    // --- CÁLCULO CORREGIDO ---
                    // Se utiliza la nueva función para obtener la posición 3D precisa
                    const worldPosition = mapHandTo3DWorld(palm, zPos);

                    // Actualizar la posición del atractor invisible y el puntero visible
                    handAttractors[index].copy(worldPosition);
                    handMarkers[index].position.copy(worldPosition);
                });
            }

            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const i3 = i * 3;
                const particlePos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                handAttractors.forEach(attractor => {
                    const direction = attractor.clone().sub(particlePos);
                    const distSq = direction.lengthSq();
                    if (distSq > 1) {
                         const force = direction.normalize().multiplyScalar(ATTRACTION_FORCE / distSq);
                         particleVelocities[i3] += force.x;
                         particleVelocities[i3 + 1] += force.y;
                         particleVelocities[i3 + 2] += force.z;
                    }
                });
                particleVelocities[i3] *= DAMPING;
                particleVelocities[i3 + 1] *= DAMPING;
                particleVelocities[i3 + 2] *= DAMPING;
                positions[i3] += particleVelocities[i3];
                positions[i3 + 1] += particleVelocities[i3 + 1];
                positions[i3 + 2] += particleVelocities[i3 + 2];
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y += 0.0001;

            composer.render();
        }
    </script>
</body>
</html>
