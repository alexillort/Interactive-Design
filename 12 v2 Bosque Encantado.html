<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Bosque Encantado</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { position: absolute; top: 0; left: 0; transform: scaleX(-1); }
        #background-canvas { z-index: 1; }
        #interaction-canvas { z-index: 2; }
        #input_video { display: none; } 
    </style>
</head>
<body>
    <video id="input_video" autoplay playsinline></video>
    <canvas id="background-canvas"></canvas>
    <canvas id="interaction-canvas"></canvas>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const video = document.getElementById("input_video");
        const bgCanvas = document.getElementById("background-canvas");
        const bgCtx = bgCanvas.getContext("2d");
        const intCanvas = document.getElementById("interaction-canvas");
        const intCtx = intCanvas.getContext("2d");
        
        let handLandmarker;
        let particles = [];
        let lastHandPositions = [];

        class MagicParticle {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.life = 1.0;
                if (type === 'spore') {
                    this.vx = (Math.random() - 0.5) * 0.5; this.vy = Math.random() * -1 - 0.5;
                    this.size = Math.random() * 2 + 1; this.color = `hsla(${120 + Math.random() * 60}, 100%, 70%, 0.7)`;
                } else { // firefly
                    this.vx = (Math.random() - 0.5) * 3; this.vy = (Math.random() - 0.5) * 3;
                    this.size = Math.random() * 3 + 2; this.color = `hsla(${40 + Math.random() * 40}, 100%, 70%, 1)`;
                }
            }
            update() {
                if (this.type === 'firefly') {
                    this.vx += (Math.random() - 0.5) * 0.5; this.vy += (Math.random() - 0.5) * 0.5;
                    this.vx = Math.max(-2, Math.min(2, this.vx)); this.vy = Math.max(-2, Math.min(2, this.vy));
                }
                this.x += this.vx; this.y += this.vy; this.life -= 0.01;
            }
            draw() {
                intCtx.globalAlpha = this.life; intCtx.fillStyle = this.color;
                intCtx.shadowBlur = 8; intCtx.shadowColor = this.color;
                intCtx.beginPath(); intCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2); intCtx.fill();
            }
        }

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, { 
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2 
            });
            startCamera();
        }
        createHandLandmarker();

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    [bgCanvas, intCanvas].forEach(c => { c.width = video.videoWidth; c.height = video.videoHeight; });
                    const scaleFactor = Math.min(window.innerWidth / video.videoWidth, window.innerHeight / video.videoHeight);
                    [bgCanvas, intCanvas].forEach(c => { 
                        c.style.width = `${video.videoWidth * scaleFactor}px`; c.style.height = `${video.videoHeight * scaleFactor}px`;
                        c.style.left = `${(window.innerWidth - (video.videoWidth * scaleFactor)) / 2}px`;
                        c.style.top = `${(window.innerHeight - (video.videoHeight * scaleFactor)) / 2}px`;
                    });
                    animate();
                });
            });
        }

        function animate() {
            bgCtx.drawImage(video, 0, 0, bgCanvas.width, bgCanvas.height);
            
            // --- CAMBIO CLAVE AQUÃ ---
            // Se reemplaza el relleno negro por una limpieza transparente del canvas.
            intCtx.clearRect(0, 0, intCanvas.width, intCanvas.height);
            
            if (handLandmarker) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                if (results.landmarks && results.landmarks.length > 0) {
                    results.landmarks.forEach((landmarks, index) => {
                        const palmCenter = landmarks[9];
                        const currentPos = { x: palmCenter.x * intCanvas.width, y: palmCenter.y * intCanvas.height };
                        if (Math.random() > 0.5) {
                            particles.push(new MagicParticle(currentPos.x, currentPos.y, 'spore'));
                        }
                        if(lastHandPositions[index]) {
                            const dx = currentPos.x - lastHandPositions[index].x;
                            const dy = currentPos.y - lastHandPositions[index].y;
                            const velocity = Math.sqrt(dx*dx + dy*dy);
                            if (velocity > 15) {
                                particles.push(new MagicParticle(currentPos.x, currentPos.y, 'firefly'));
                            }
                        }
                        lastHandPositions[index] = currentPos;
                    });
                }
            }
            
            particles.forEach((p, index) => {
                p.update();
                if (p.life <= 0) {
                    particles.splice(index, 1);
                } else {
                    p.draw();
                }
            });
            intCtx.shadowBlur = 0;
            intCtx.globalAlpha = 1;

            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>