<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Explosión de Fuegos Artificiales</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        /* Volteamos el video para que el movimiento de la mano sea intuitivo */
        #webcam { display: none; transform: scaleX(-1); }
        #threejs-canvas { display: block; }
        #loading-message {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-family: Arial, sans-serif;
            font-size: 1.2em; text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading-message">Cargando MediaPipe y cámara...</div>
    <video id="webcam" autoplay playsinline></video>
    <canvas id="threejs-canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        let scene, camera, renderer;
        let particleSystem;
        const NUM_PARTICLES = 10000; // Suficientes partículas para una buena explosión

        let handLandmarker;
        let video;
        let lastVideoTime = -1;
        let detections = null;

        // --- Ajustes para el efecto de fuegos artificiales ---
        const PARTICLE_LIFETIME = 180; // Vida útil de la chispa en frames (3 segundos a 60fps)
        const EXPLOSION_IMPULSE = 0.2; // Fuerza de la explosión
        const PARTICLE_GRAVITY = 0.005; // Gravedad para que las chispas caigan
        const DAMPING_FACTOR = 0.97; // Fricción para que se ralenticen

        // Umbral para detectar el puño cerrado vs mano abierta
        const GESTURE_THRESHOLD = 0.15; // Distancia promedio de los dedos a la palma

        // Paleta de colores para los fuegos artificiales
        const FIREWORK_COLORS = [
            new THREE.Color(0xFFFFFF), // Blanco brillante
            new THREE.Color(0xFFD700), // Dorado
            new THREE.Color(0xFF4500), // Naranja rojizo
            new THREE.Color(0xDC143C)  // Rojo carmesí
        ];

        // Buffers para los atributos de las partículas
        let positions, colors;
        
        // Arrays para gestionar el estado de cada partícula
        const particleVelocities = [];
        const particleLifetimes = []; // Vida útil restante
        const particleInitialColors = []; // Color inicial de la chispa
        
        let particleCursor = 0; // Para reciclar partículas
        const handPosition = new THREE.Vector3(); // Posición de la palma
        let wasHandOpen = false; // Estado anterior de la mano para detectar el cambio
        let lastExplosionTime = 0; // Para evitar explosiones muy seguidas

        function createParticleSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const context = canvas.getContext('2d');
            context.beginPath();
            context.arc(8, 8, 8, 0, 2 * Math.PI);
            context.fillStyle = 'white'; // Un círculo blanco para la textura
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('threejs-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            camera.position.z = 10; // Cámara ligeramente retirada

            const particleGeometry = new THREE.BufferGeometry();
            
            // Inicializar los arrays de atributos
            positions = new Float32Array(NUM_PARTICLES * 3);
            colors = new Float32Array(NUM_PARTICLES * 3);

            for (let i = 0; i < NUM_PARTICLES; i++) {
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = -1000; // Partículas "muertas" fuera de vista
                colors[i * 3] = 0;
                colors[i * 3 + 1] = 0;
                colors[i * 3 + 2] = 0;

                particleVelocities.push(new THREE.Vector3());
                particleLifetimes.push(0);
                particleInitialColors.push(new THREE.Color());
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: 0.15, // Tamaño de las chispas
                map: createParticleSprite(),
                blending: THREE.AdditiveBlending, // Para el efecto de brillo
                transparent: true,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO",
                numHands: 1 // Solo necesitamos una mano para el gesto
            });
            document.getElementById('loading-message').textContent = "Iniciando cámara...";
            setupWebcam();
        }

        async function setupWebcam() {
            video = document.getElementById("webcam");
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    document.getElementById('loading-message').style.display = 'none';
                    animate();
                });
            } catch (error) {
                console.error("Error al acceder a la cámara:", error);
                document.getElementById('loading-message').textContent = "Error: No se pudo acceder a la cámara.";
            }
        }

        // --- Mapeo de coordenadas de MediaPipe a Three.js ---
        function mapTo3DWorld(point) {
            const vec = new THREE.Vector3();
            // Invertimos X porque el video está volteado (transform: scaleX(-1))
            vec.x = (1.0 - point.x - 0.5) * 15; 
            vec.y = -(point.y - 0.5) * 12;
            vec.z = (point.z * -1) * 30; // Z para profundidad
            return vec;
        }

        // --- Detección de gesto de mano abierta/cerrada ---
        function detectHandOpen(landmarks) {
            const FINGER_TIPS = [4, 8, 12, 16, 20]; // Puntos de las yemas de los dedos
            const palmBase = landmarks[0]; // Base de la palma
            
            let totalDistance = 0;
            FINGER_TIPS.forEach(tipIndex => {
                const tip = landmarks[tipIndex];
                // Distancia euclidiana entre la punta del dedo y la base de la palma
                totalDistance += Math.hypot(tip.x - palmBase.x, tip.y - palmBase.y, tip.z - palmBase.z);
            });
            
            const averageDistance = totalDistance / FINGER_TIPS.length;
            // Si la distancia promedio es mayor que el umbral, la mano está abierta
            return averageDistance > GESTURE_THRESHOLD;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (video.readyState === 4 && handLandmarker) {
                const nowInMs = Date.now();
                if (lastVideoTime !== video.currentTime) {
                    lastVideoTime = video.currentTime;
                    detections = handLandmarker.detectForVideo(video, nowInMs);
                }
            }
            
            let isHandDetected = false;
            let currentHandOpen = false;

            if (detections && detections.landmarks && detections.landmarks.length > 0) {
                isHandDetected = true;
                const landmarks = detections.landmarks[0]; // Solo una mano
                const palmCenter = landmarks[9]; // Centro de la palma
                
                handPosition.copy(mapTo3DWorld(palmCenter));
                currentHandOpen = detectHandOpen(landmarks);

                // --- Lógica de la Explosión de Fuegos Artificiales ---
                // Detectar el cambio de puño cerrado a mano abierta
                if (!wasHandOpen && currentHandOpen && (performance.now() - lastExplosionTime > 500)) { // 500ms de cooldown
                    // ¡DISPARAR EXPLOSIÓN!
                    for (let i = 0; i < NUM_PARTICLES; i++) {
                        const pIndex = particleCursor;

                        // Las partículas nacen en la posición de la palma
                        positions[pIndex * 3] = handPosition.x;
                        positions[pIndex * 3 + 1] = handPosition.y;
                        positions[pIndex * 3 + 2] = handPosition.z;

                        // Impulso radial aleatorio (dirección de explosión)
                        const impulse = new THREE.Vector3().randomDirection().multiplyScalar(EXPLOSION_IMPULSE * (0.8 + Math.random() * 0.4));
                        particleVelocities[pIndex].copy(impulse);

                        // Asignar vida y un color aleatorio de la paleta
                        particleLifetimes[pIndex] = PARTICLE_LIFETIME;
                        const initialColor = FIREWORK_COLORS[Math.floor(Math.random() * FIREWORK_COLORS.length)];
                        particleInitialColors[pIndex].copy(initialColor); // Guardar color inicial
                        initialColor.toArray(colors, pIndex * 3); // Aplicar color inicial

                        particleCursor = (particleCursor + 1) % NUM_PARTICLES;
                    }
                    lastExplosionTime = performance.now();
                }
            }
            wasHandOpen = currentHandOpen; // Actualizar el estado para el próximo frame


            // Actualizar todas las partículas
            const tempColor = new THREE.Color();
            for (let i = 0; i < NUM_PARTICLES; i++) {
                if (particleLifetimes[i] > 0) {
                    particleLifetimes[i]--; // Reducir vida

                    // Aplicar física
                    particleVelocities[i].y -= PARTICLE_GRAVITY;
                    particleVelocities[i].multiplyScalar(DAMPING_FACTOR);
                    positions[i * 3] += particleVelocities[i].x;
                    positions[i * 3 + 1] += particleVelocities[i].y;
                    positions[i * 3 + 2] += particleVelocities[i].z;

                    // Desvanecer el color y la opacidad a medida que la chispa "muere"
                    const lifeRatio = particleLifetimes[i] / PARTICLE_LIFETIME;
                    
                    tempColor.copy(particleInitialColors[i]);
                    tempColor.multiplyScalar(lifeRatio); // El color se desvanece a negro
                    tempColor.toArray(colors, i * 3);

                } else {
                    // Partícula "muerta", la hacemos invisible
                    colors[i * 3] = 0;
                    colors[i * 3 + 1] = 0;
                    colors[i * 3 + 2] = 0;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        initThreeJS();
        createHandLandmarker();
    </script>
</body>
</html>
