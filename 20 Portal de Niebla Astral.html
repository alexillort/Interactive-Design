<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Portal de Niebla Astral</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; }
        #render-canvas { position: absolute; top: 0; left: 0; }
        #input_video { transform: scaleX(-1); display: none; }
    </style>
</head>
<body>
    <video id="input_video" autoplay playsinline></video>
    <canvas id="render-canvas"></canvas>

    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.164.1/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const video = document.getElementById("input_video");
        let handLandmarker;
        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });
            startCamera();
        }
        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    init();
                    animate();
                });
            });
        }
        createHandLandmarker();

        let scene, camera, renderer, clock;
        let fogMeshes = [];
        const handInteractions = [
            { position: new THREE.Vector3(0,0,-1000), density: 0 },
            { position: new THREE.Vector3(0,0,-1000), density: 0 }
        ];
        
        // --- CAMBIO 1: Variables para los punteros y su visibilidad ---
        let handMarkers = [];
        let showPointers = false;

        const NUM_FOG_LAYERS = 20;
        const FOG_RADIUS = 150;
        const INTERACTION_RADIUS = 80;
        const MIN_PINCH_DIST = 0.03;
        const MAX_PINCH_DIST = 0.2;

        const fogVertexShader = `
            varying vec3 vWorldPosition;
            void main() {
                vec4 modelPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = modelPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const fogFragmentShader = `
            uniform float time;
            uniform vec3 hand1Pos; uniform float hand1Density;
            uniform vec3 hand2Pos; uniform float hand2Density;
            uniform float interactionRadius;
            varying vec3 vWorldPosition;

            float random(vec3 p) { return fract(sin(dot(p.xyz, vec3(12.9898, 78.233, 151.7182))) * 43758.5453); }
            float noise(vec3 p) {
                vec3 i = floor(p); vec3 f = fract(p); f = f * f * (3.0 - 2.0 * f);
                float a = random(i + vec3(0.,0.,0.)); float b = random(i + vec3(1.,0.,0.));
                float c = random(i + vec3(0.,1.,0.)); float d = random(i + vec3(1.,1.,0.));
                float e = random(i + vec3(0.,0.,1.)); float f_ = random(i + vec3(1.,0.,1.));
                float g = random(i + vec3(0.,1.,1.)); float h = random(i + vec3(1.,1.,1.));
                return mix(mix(mix(a, b, f.x), mix(c, d, f.x), f.y),
                           mix(mix(e, f_, f.x), mix(g, h, f.x), f.y), f.z);
            }
            
            void main() {
                float baseNoise = 0.0;
                baseNoise += noise(vWorldPosition * 0.01 + time * 0.05) * 1.0;
                baseNoise += noise(vWorldPosition * 0.03 + time * 0.1) * 0.5;
                baseNoise += noise(vWorldPosition * 0.06) * 0.25;
                baseNoise /= 1.75;
                float alpha = baseNoise * 0.15;
                vec3 color = vec3(0.0);

                float dist1 = distance(vWorldPosition, hand1Pos);
                if (dist1 < interactionRadius) {
                    float influence1 = 1.0 - dist1 / interactionRadius;
                    alpha += influence1 * hand1Density * 0.5;
                    color += vec3(0.0, 0.5, 1.0) * influence1 * hand1Density * 2.0;
                }
                float dist2 = distance(vWorldPosition, hand2Pos);
                if (dist2 < interactionRadius) {
                    float influence2 = 1.0 - dist2 / interactionRadius;
                    alpha += influence2 * hand2Density * 0.5;
                    color += vec3(1.0, 0.3, 0.0) * influence2 * hand2Density * 2.0;
                }
                gl_FragColor = vec4(color, alpha);
            }
        `;
        
        // --- CAMBIO 2: Función para activar la visibilidad de los punteros ---
        function activatePointers() {
            showPointers = true;
            window.removeEventListener('click', activatePointers);
            window.removeEventListener('touchstart', activatePointers);
            document.body.style.cursor = 'default';
        }
        window.addEventListener('click', activatePointers);
        window.addEventListener('touchstart', activatePointers);


        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 150;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('render-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 1);

            clock = new THREE.Clock();

            const fogGeometry = new THREE.PlaneGeometry(FOG_RADIUS * 3, FOG_RADIUS * 3, 1, 1);
            for (let i = 0; i < NUM_FOG_LAYERS; i++) {
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        hand1Pos: { value: handInteractions[0].position }, hand1Density: { value: handInteractions[0].density },
                        hand2Pos: { value: handInteractions[1].position }, hand2Density: { value: handInteractions[1].density },
                        interactionRadius: { value: INTERACTION_RADIUS }
                    },
                    vertexShader: fogVertexShader, fragmentShader: fogFragmentShader,
                    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
                });
                const mesh = new THREE.Mesh(fogGeometry, material);
                mesh.position.z = (i / NUM_FOG_LAYERS - 0.5) * FOG_RADIUS * 2;
                fogMeshes.push(mesh);
                scene.add(mesh);
            }
            
            // --- CAMBIO 3: Crear los objetos 3D para los punteros ---
            const markerGeometry = new THREE.SphereGeometry(3, 16, 16); // Esferas de radio 3
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffaa, toneMapped: false });
            for(let i=0; i<2; i++) {
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.visible = false; // Inician invisibles
                scene.add(marker);
                handMarkers.push(marker);
            }
            
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- CAMBIO 4: Función mejorada para alinear la mano con el mundo 3D ---
        function mapHandTo3DWorld(point, targetZ) {
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * Math.abs(targetZ - camera.position.z);
            const visibleWidth = visibleHeight * camera.aspect;
            const worldX = -(point.x - 0.5) * visibleWidth;
            const worldY = -(point.y - 0.5) * visibleHeight;
            return new THREE.Vector3(worldX, worldY, targetZ);
        }

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const results = handLandmarker?.detectForVideo(video, performance.now());
            
            // Resetear posiciones y visibilidad
            handInteractions.forEach(hand => { hand.position.z = -1000; hand.density = 0; });
            handMarkers.forEach(marker => marker.visible = false);

            if (results?.landmarks) {
                results.landmarks.forEach((landmarks, index) => {
                    const palm = landmarks[9];
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                    const density = THREE.MathUtils.mapLinear(pinchDist, MAX_PINCH_DIST, MIN_PINCH_DIST, 0.0, 1.0);
                    
                    // Se usa la función mejorada para calcular la posición
                    const worldPosition = mapHandTo3DWorld(palm, 0);

                    handInteractions[index].position.copy(worldPosition);
                    handInteractions[index].density = THREE.MathUtils.clamp(density, 0.0, 1.0);

                    // --- CAMBIO 5: Actualizar la posición y visibilidad del puntero ---
                    handMarkers[index].position.copy(worldPosition);
                    if (showPointers) {
                        handMarkers[index].visible = true;
                    }
                });
            }

            fogMeshes.forEach(mesh => {
                mesh.material.uniforms.time.value = elapsedTime;
                // (El resto de las actualizaciones de uniforms no cambia)
                mesh.material.uniforms.hand1Pos.value.copy(handInteractions[0].position);
                mesh.material.uniforms.hand1Density.value = handInteractions[0].density;
                mesh.material.uniforms.hand2Pos.value.copy(handInteractions[1].position);
                mesh.material.uniforms.hand2Density.value = handInteractions[1].density;
                mesh.rotation.z += 0.0005 * (mesh.position.z / FOG_RADIUS);
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
