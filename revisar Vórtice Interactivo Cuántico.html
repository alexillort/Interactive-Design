<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Vórtice Interactivo Cuántico</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #input_video { display: none; }
        #loading-message {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-family: Arial, sans-serif;
            font-size: 1.2em; text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading-message">Cargando MediaPipe y cámara...</div>
    <video id="input_video" autoplay playsinline></video>
    <div id="container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        let handLandmarker, scene, camera, renderer, composer, videoTexture, backgroundPlane;
        const video = document.getElementById("input_video");
        const container = document.getElementById("container");
        const loadingMessage = document.getElementById('loading-message');

        const NUM_HANDS = 2;
        const NUM_LANDMARKS = 21;
        const EMITTER_POINTS = [0, 5, 9, 13, 17]; // Muñeca y bases de los dedos
        const MAX_PARTICLES_PER_HAND = 2000;
        const PARTICLES_PER_EMITTER_PER_FRAME = 2;
        const PARTICLE_TRAIL_LENGTH = 5; // Cuántos segmentos tiene el rastro de la partícula
        const MAX_CONNECTIONS = 10000;
        const CONNECTION_DISTANCE = 3.0;
        const PARTICLE_LIFETIME = 250;
        const PARTICLE_EMIT_SPEED = 0.5;
        const DAMPING = 0.98; // Fricción
        const GESTURE_THRESHOLD = 0.18; // Umbral para detectar puño cerrado
        const BULLET_TIME_FACTOR = 0.1; // Ralentización del tiempo
        const BULLET_TIME_DURATION = 300; // Duración en frames del Bullet Time

        // --- Campos de Fuerza ---
        const FIELD_RADIUS = 15; // Radio de influencia de la mano
        const ATTRACT_STRENGTH = 0.08; // Fuerza de atracción (puño)
        const REPEL_STRENGTH = 0.05; // Fuerza de repulsión (mano abierta)
        const HAND_SPEED_FACTOR = 0.5; // Multiplicador para fuerza del campo según velocidad de mano

        // --- Colores ---
        const HAND_COLORS_HSL = [
            { h: 0.6, s: 1.0, l: 0.5 }, // Mano Izquierda (azul/violeta)
            { h: 0.2, s: 1.0, l: 0.5 }  // Mano Derecha (verde/amarillo)
        ];
        const SPEED_COLOR_CHANGE = 0.1;
        const CONNECTION_COLOR_BLEND = 0.2;

        // --- Variables de estado ---
        let allParticles = [];
        let particlesPool = [];
        let activeParticlesCount = 0;
        let lastHandPos = [new THREE.Vector3(), new THREE.Vector3()];
        let handVelocity = [new THREE.Vector3(), new THREE.Vector3()];
        let handLandmarkPositions = [new Array(NUM_LANDMARKS), new Array(NUM_LANDMARKS)];
        let isFist = [false, false];
        let lastFistTime = [0, 0];
        let bulletTimeActive = false;
        let bulletTimeTimer = 0;

        let particleVertexPositions, particleVertexColors;
        let particleTrailSystem; // LineSegments para los trails
        let connectionPositions, connectionColors;
        let connectionSystem;

        // --- Clase para una partícula individual (ahora con rastro) ---
        class Particle {
            constructor(index) {
                this.index = index; // Índice en el array global allParticles
                this.trailPositions = []; // Almacena puntos anteriores para el rastro
                for(let i=0; i < PARTICLE_TRAIL_LENGTH; i++) {
                    this.trailPositions.push(new THREE.Vector3());
                }
                this.vel = new THREE.Vector3();
                this.baseColor = new THREE.Color();
                this.lifetime = 0;
                this.maxLifetime = 0;
                this.isActive = false;
            }

            init(position, velocity, color, maxLifetime) {
                this.trailPositions.forEach(p => p.copy(position)); // Inicializa todo el rastro en la posición inicial
                this.vel.copy(velocity);
                this.baseColor.copy(color);
                this.lifetime = maxLifetime;
                this.maxLifetime = maxLifetime;
                this.isActive = true;
            }

            update(deltaTime, handData) {
                if (!this.isActive) return;

                this.lifetime -= deltaTime;
                if (this.lifetime <= 0) {
                    this.isActive = false;
                    return;
                }

                // Desplazar el rastro
                for(let i = this.trailPositions.length - 1; i > 0; i--) {
                    this.trailPositions[i].copy(this.trailPositions[i-1]);
                }
                this.trailPositions[0].copy(this.trailPositions[0]).add(this.vel.clone().multiplyScalar(deltaTime)); // El punto más nuevo se actualiza con la velocidad
                
                // Aplicar campos de fuerza de las manos
                handData.forEach((hand, handIndex) => {
                    if (!hand.detected) return;
                    
                    const distToHand = this.trailPositions[0].distanceTo(hand.palmCenter);
                    if (distToHand < FIELD_RADIUS) {
                        const forceDirection = new THREE.Vector3().subVectors(hand.palmCenter, this.trailPositions[0]).normalize();
                        let forceMagnitude = 0;

                        if (hand.isFist) { // Puño: atrae
                            forceMagnitude = ATTRACT_STRENGTH * (1 - distToHand / FIELD_RADIUS);
                        } else { // Mano abierta: repele
                            forceMagnitude = -REPEL_STRENGTH * (1 - distToHand / FIELD_RADIUS);
                        }
                        // La fuerza es mayor si la mano se mueve rápido
                        forceMagnitude *= (1 + hand.speed * HAND_SPEED_FACTOR);
                        
                        this.vel.add(forceDirection.multiplyScalar(forceMagnitude * deltaTime));
                    }
                });

                this.vel.multiplyScalar(DAMPING);
            }

            updateBuffers(positionsArray, colorsArray) {
                if (!this.isActive) {
                    for(let i = 0; i < PARTICLE_TRAIL_LENGTH * 2; i++) { // Cada segmento tiene 2 vértices (inicio y fin)
                        const idx = (this.index * PARTICLE_TRAIL_LENGTH * 2 + i) * 3;
                        positionsArray[idx] = positionsArray[idx+1] = positionsArray[idx+2] = -1000;
                        colorsArray[idx] = colorsArray[idx+1] = colorsArray[idx+2] = 0;
                    }
                    return;
                }

                const lifeRatio = this.lifetime / this.maxLifetime;
                for(let i = 0; i < PARTICLE_TRAIL_LENGTH - 1; i++) {
                    const currentPos = this.trailPositions[i];
                    const nextPos = this.trailPositions[i+1];
                    const idx = (this.index * (PARTICLE_TRAIL_LENGTH - 1) * 2 + i * 2) * 3; // (indice de particula * segmentos * 2 vertices por segmento + indice de segmento * 2 vertices) * 3 componentes (x,y,z)
                    
                    currentPos.toArray(positionsArray, idx);
                    nextPos.toArray(positionsArray, idx + 3);

                    // Color se desvanece por la cola y por la vida útil total
                    const segmentLifeRatio = lifeRatio * (1 - (i / PARTICLE_TRAIL_LENGTH));
                    const tempColor = this.baseColor.clone().multiplyScalar(segmentLifeRatio * segmentLifeRatio);
                    
                    tempColor.toArray(colorsArray, idx);
                    tempColor.toArray(colorsArray, idx + 3); // Ambos extremos del segmento tienen el mismo color por ahora
                }
            }
        }

        async function setupMediapipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO",
                numHands: NUM_HANDS
            });
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: { width: {ideal: 1280}, height: {ideal: 720} } }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    video.width = video.videoWidth;
                    video.height = video.videoHeight;
                    loadingMessage.style.display = 'none';
                    setupThreeJS();
                    animate();
                });
            }).catch(error => {
                console.error("Error al acceder a la cámara:", error);
                loadingMessage.textContent = "Error: No se pudo acceder a la cámara.";
            });
        }

        function setupThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: container.appendChild(document.createElement('canvas')) });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.wrapS = THREE.RepeatWrapping;
            videoTexture.repeat.x = -1; 
            
            const planeGeo = new THREE.PlaneGeometry(1, 1);
            const planeMat = new THREE.MeshBasicMaterial({ map: videoTexture, color: 0x222222 }); // Fondo oscuro
            backgroundPlane = new THREE.Mesh(planeGeo, planeMat);
            scene.add(backgroundPlane);

            // --- PARTICULAS AHORA COMO LINE_SEGMENTS (RASTROS) ---
            const totalParticleSegments = MAX_PARTICLES_PER_HAND * NUM_HANDS * (PARTICLE_TRAIL_LENGTH - 1);
            const particleGeometry = new THREE.BufferGeometry();
            particleVertexPositions = new Float32Array(totalParticleSegments * 2 * 3); // Cada segmento tiene 2 vértices
            particleVertexColors = new Float32Array(totalParticleSegments * 2 * 3);
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particleVertexPositions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleVertexColors, 3));
            const particleMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            particleTrailSystem = new THREE.LineSegments(particleGeometry, particleMaterial);
            scene.add(particleTrailSystem);

            // Geometría para las conexiones (líneas)
            const connectionGeometry = new THREE.BufferGeometry();
            connectionPositions = new Float32Array(MAX_CONNECTIONS * 2 * 3);
            connectionColors = new Float32Array(MAX_CONNECTIONS * 2 * 3);
            connectionGeometry.setAttribute('position', new THREE.BufferAttribute(connectionPositions, 3));
            connectionGeometry.setAttribute('color', new THREE.BufferAttribute(connectionColors, 3));
            const connectionMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            connectionSystem = new THREE.LineSegments(connectionGeometry, connectionMaterial);
            scene.add(connectionSystem);

            for (let i = 0; i < MAX_PARTICLES_PER_HAND * NUM_HANDS; i++) {
                const particle = new Particle(i);
                allParticles.push(particle);
                particlesPool.push(particle);
            }
            
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.85); 
            bloomPass.threshold = 0;
            bloomPass.strength = 1.0;
            bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
            onWindowResize();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            if (backgroundPlane) {
                const vFOV = THREE.MathUtils.degToRad(camera.fov);
                const planeHeight = 2 * Math.tan(vFOV / 2) * Math.abs(camera.position.z);
                const planeWidth = planeHeight * camera.aspect;
                backgroundPlane.scale.set(planeWidth, planeHeight, 1);
            }
        }
        
        function mapTo3DWorld(point, zOffset = 0) {
            const z = zOffset; 
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const height = 2 * Math.tan(vFOV / 2) * Math.abs(camera.position.z - z);
            const width = height * camera.aspect;
            
            const vec = new THREE.Vector3();
            vec.x = (1.0 - point.x - 0.5) * width;
            vec.y = -(point.y - 0.5) * height;
            vec.z = z;
            return vec;
        }

        // --- Detección de gestos ---
        function detectGesture(landmarks) {
            const FINGER_TIPS = [4, 8, 12, 16, 20];
            const palm = landmarks[0]; // Muñeca o base de la palma
            let totalDistance = 0;
            for (const tipIndex of FINGER_TIPS) {
                const tip = landmarks[tipIndex];
                totalDistance += Math.hypot(tip.x - palm.x, tip.y - palm.y, tip.z - palm.z);
            }
            return (totalDistance / FINGER_TIPS.length) < GESTURE_THRESHOLD;
        }

        function animate() {
            let deltaTime = 1;
            if (bulletTimeActive) {
                deltaTime = BULLET_TIME_FACTOR;
                bulletTimeTimer--;
                if (bulletTimeTimer <= 0) {
                    bulletTimeActive = false;
                }
            }

            requestAnimationFrame(animate);
            const results = handLandmarker?.detectForVideo(video, performance.now());
            
            let handData = []; // [{ detected, isFist, palmCenter, speed }]
            let allLandmarkPositions = [];
            
            // Reiniciar conexiones
            let currentConnection = 0;
            for (let i = 0; i < MAX_CONNECTIONS * 2 * 3; i++) connectionPositions[i] = -1000;


            for(let i=0; i < NUM_HANDS; i++) {
                handData.push({
                    detected: false,
                    isFist: false,
                    palmCenter: new THREE.Vector3(),
                    speed: 0
                });
            }

            if (results?.landmarks) {
                results.landmarks.forEach((landmarks, handIndex) => {
                    handData[handIndex].detected = true;
                    handData[handIndex].isFist = detectGesture(landmarks);

                    const palmCenter = mapTo3DWorld(landmarks[9], 0);
                    handData[handIndex].palmCenter.copy(palmCenter);

                    const wristPos = mapTo3DWorld(landmarks[0], 0);
                    handVelocity[handIndex].subVectors(wristPos, lastHandPos[handIndex]);
                    lastHandPos[handIndex].copy(wristPos);
                    handData[handIndex].speed = handVelocity[handIndex].length();
                    
                    landmarks.forEach((landmark, i) => {
                        const pos = mapTo3DWorld(landmark, 0);
                        handLandmarkPositions[handIndex][i] = pos;
                        allLandmarkPositions.push(pos);
                    });

                    // --- EMITIR PARTICULAS ---
                    EMITTER_POINTS.forEach(landmarkIndex => {
                        const emitterPos = handLandmarkPositions[handIndex][landmarkIndex];
                        if (emitterPos) {
                            for (let i = 0; i < PARTICLES_PER_EMITTER_PER_FRAME; i++) {
                                if (particlesPool.length > 0) {
                                    const particle = particlesPool.shift();
                                    const initialVel = new THREE.Vector3().randomDirection().multiplyScalar(PARTICLE_EMIT_SPEED);
                                    
                                    const colorHue = (HAND_COLORS_HSL[handIndex].h + handData[handIndex].speed * SPEED_COLOR_CHANGE) % 1.0;
                                    const particleColor = new THREE.Color().setHSL(colorHue, HAND_COLORS_HSL[handIndex].s, HAND_COLORS_HSL[handIndex].l);
                                    
                                    particle.init(emitterPos, initialVel, particleColor, PARTICLE_LIFETIME * (0.8 + Math.random() * 0.4));
                                }
                            }
                        }
                    });
                });
            }

            // --- GESTOS COMPLEJOS ---
            // Bullet Time
            handData.forEach((hand, handIndex) => {
                if (hand.detected && hand.isFist && !isFist[handIndex]) { // Si acaba de cerrar el puño
                    if (performance.now() - lastFistTime[handIndex] < 300) { // Si fue un doble click rápido
                        bulletTimeActive = true;
                        bulletTimeTimer = BULLET_TIME_DURATION;
                    }
                    lastFistTime[handIndex] = performance.now();
                }
                isFist[handIndex] = hand.isFist;
            });
            
            // Implosión/Explosión
            if (handData[0].detected && handData[1].detected) {
                const distanceBetweenPalms = handData[0].palmCenter.distanceTo(handData[1].palmCenter);
                if (distanceBetweenPalms < 5 && handData[0].isFist && handData[1].isFist) {
                    // Juntar puños: Implosión seguida de explosión
                    const center = new THREE.Vector3().addVectors(handData[0].palmCenter, handData[1].palmCenter).multiplyScalar(0.5);
                    allParticles.forEach(p => {
                        if (p.isActive) {
                            p.vel.subVectors(center, p.trailPositions[0]).normalize().multiplyScalar(1.0); // Atraer al centro
                            p.lifetime = 100; // Recortar vida para forzar implosión rápida
                        }
                    });
                } else if (distanceBetweenPalms > 20 && !handData[0].isFist && !handData[1].isFist && handData[0].speed > 1 && handData[1].speed > 1) {
                    // Separar manos abiertas rápido: Onda expansiva
                     allParticles.forEach(p => {
                        if (p.isActive) {
                            p.vel.copy(handData[0].palmCenter).sub(handData[1].palmCenter).normalize().multiplyScalar(2.0); // Repeler fuertemente
                            p.lifetime = PARTICLE_LIFETIME; // Resetear vida
                        }
                    });
                }
            }

            // --- Actualizar y renderizar partículas ---
            activeParticlesCount = 0;
            for(let i=0; i < allParticles.length; i++) {
                const p = allParticles[i];
                if (p.isActive) {
                    p.update(deltaTime, handData);
                    p.updateBuffers(particleVertexPositions, particleVertexColors);
                    activeParticlesCount++;
                } else if (!particlesPool.includes(p)) {
                    particlesPool.push(p);
                }
            }

            // --- Forjar conexiones entre partículas y puntos de la mano ---
            for (let i = 0; i < allParticles.length; i++) {
                if (currentConnection >= MAX_CONNECTIONS) break;
                if (!allParticles[i].isActive) continue;

                const pA = allParticles[i];
                
                // Conectar a los puntos de la mano más cercanos
                allLandmarkPositions.forEach(landmarkPos => {
                    if (currentConnection >= MAX_CONNECTIONS) return;
                    const distance = pA.trailPositions[0].distanceTo(landmarkPos); // Usa la cabeza del rastro
                    if (distance < CONNECTION_DISTANCE) {
                        const idx = currentConnection * 6;
                        pA.trailPositions[0].toArray(connectionPositions, idx);
                        landmarkPos.toArray(connectionPositions, idx + 3);

                        const colorA = pA.baseColor.clone().lerp(new THREE.Color(0xFFFFFF), CONNECTION_COLOR_BLEND);
                        const colorB = new THREE.Color(0xFFFFFF); // Puntos de la mano son blancos
                        
                        (colorA.multiplyScalar(pA.lifetime / pA.maxLifetime)).toArray(connectionColors, idx);
                        colorB.toArray(connectionColors, idx + 3);
                        
                        currentConnection++;
                    }
                });
            }

            // Ocultar conexiones restantes
            for (let i = currentConnection; i < MAX_CONNECTIONS; i++) {
                const idx = i * 6;
                connectionPositions[idx] = connectionPositions[idx+1] = connectionPositions[idx+2] = -1000;
                connectionPositions[idx+3] = connectionPositions[idx+4] = connectionPositions[idx+5] = -1000;
                connectionColors[idx] = connectionColors[idx+1] = connectionColors[idx+2] = 0;
                connectionColors[idx+3] = connectionColors[idx+4] = connectionColors[idx+5] = 0;
            }

            particleTrailSystem.geometry.attributes.position.needsUpdate = true;
            particleTrailSystem.geometry.attributes.color.needsUpdate = true;
            connectionSystem.geometry.attributes.position.needsUpdate = true;
            connectionSystem.geometry.attributes.color.needsUpdate = true;
            connectionSystem.geometry.setDrawRange(0, currentConnection * 2);

            // Ajustar el número de dibujos para los trails
            particleTrailSystem.geometry.setDrawRange(0, activeParticlesCount * (PARTICLE_TRAIL_LENGTH - 1) * 2);

            composer.render();
        }

        setupMediapipe();
    </script>
</body>
</html>
