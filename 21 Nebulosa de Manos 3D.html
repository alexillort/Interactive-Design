<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Nebulosa de Manos 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #input_video { display: none; }
    </style>
</head>
<body>
    <video id="input_video" autoplay playsinline></video>
    <div id="container"></div>

    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const FINGER_TIPS = [4, 8, 12, 16, 20];

        let handLandmarker;
        let scene, camera, renderer, videoTexture;
        const handMeshes = [null, null];
        let backgroundPlane;

        const video = document.getElementById("input_video");
        const container = document.getElementById("container");

        async function setupMediapipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    video.width = video.videoWidth;
                    video.height = video.videoHeight;
                    setupThreeJS();
                    animate();
                });
            }).catch(err => console.error("Error al acceder a la cámara:", err));
        }

        function setupThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 1.5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            
            const backgroundPlaneGeo = new THREE.PlaneGeometry(1, 1);
            const backgroundPlaneMat = new THREE.MeshBasicMaterial({ map: videoTexture });
            backgroundPlane = new THREE.Mesh(backgroundPlaneGeo, backgroundPlaneMat);
            backgroundPlane.position.z = -0.5;
            scene.add(backgroundPlane);

            // Se ajusta el tamaño del plano para que coincida perfectamente con la vista
            fitBackgroundToView();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(0, 0, 2);
            scene.add(pointLight);

            window.addEventListener('resize', onWindowResize);
        }

        // --- FUNCIÓN SIMPLIFICADA Y CORREGIDA PARA AJUSTAR EL FONDO ---
        function fitBackgroundToView() {
            if (!video.videoWidth || !video.videoHeight) return;

            const cameraFovRad = camera.fov * Math.PI / 180;
            // Calcula el alto y ancho visible en la escena a la profundidad del plano
            const viewHeight = 2 * Math.tan(cameraFovRad / 2) * Math.abs(camera.position.z - backgroundPlane.position.z);
            const viewWidth = viewHeight * camera.aspect;

            // Ajusta la escala del plano para que coincida con la vista
            // La escala X negativa se encarga del efecto espejo
            backgroundPlane.scale.set(-viewWidth, viewHeight, 1);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Reajusta el plano en cada cambio de tamaño para mantener la alineación
            fitBackgroundToView();
        }

        function updateHandMesh(handIndex, landmarks) {
            if (!landmarks || landmarks.length === 0) {
                if(handMeshes[handIndex]) handMeshes[handIndex].visible = false;
                return;
            }

            if (!handMeshes[handIndex]) {
                const group = new THREE.Group();
                scene.add(group);
                handMeshes[handIndex] = group;
            }
            
            handMeshes[handIndex].visible = true;

            // Obtenemos el tamaño visible real del plano de fondo para el mapeo
            const viewWidth = backgroundPlane.scale.x;
            const viewHeight = backgroundPlane.scale.y;

            FINGER_TIPS.forEach(tipIndex => {
                const landmark = landmarks[tipIndex];

                // --- MAPEO DE COORDENADAS CORREGIDO Y DIRECTO ---
                // Se mapean las coordenadas (0-1) al tamaño del plano visible
                const x = (landmark.x - 0.5) * viewWidth;
                const y = -(landmark.y - 0.5) * viewHeight;
                const z = -landmark.z * 2.5 + 0.1;

                const trailGeometry = new THREE.SphereGeometry(0.03, 16, 16);
                const hue = (performance.now() / 2000 + landmark.z) % 1;
                const color = new THREE.Color().setHSL(hue, 1, 0.6);
                const trailMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
                
                const trailSphere = new THREE.Mesh(trailGeometry, trailMaterial);
                trailSphere.position.set(x, y, z);
                
                trailSphere.life = 1.0; 
                handMeshes[handIndex].add(trailSphere);
            });
        }

        function animateTrails() {
            handMeshes.forEach(group => {
                if (!group) return;
                
                const childrenToRemove = [];
                group.children.forEach(child => {
                    if (child.isMesh) {
                        child.life -= 0.015; 
                        if (child.life <= 0) {
                            childrenToRemove.push(child);
                        } else {
                            child.material.opacity = child.life;
                            // Se simplifica la animación de escala para que se encoja
                            child.scale.multiplyScalar(0.98);
                        }
                    }
                });

                childrenToRemove.forEach(child => group.remove(child));
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (handLandmarker && video.readyState >= 4) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                results.landmarks.forEach((landmarks, i) => {
                    updateHandMesh(i, landmarks);
                });
                
                // Si no se detectan manos, oculta las mallas existentes
                if (results.landmarks.length < 2 && handMeshes[1]) handMeshes[1].visible = false;
                if (results.landmarks.length < 1 && handMeshes[0]) handMeshes[0].visible = false;
            }

            animateTrails();
            
            // --- EL ESPEJO AHORA SE MANEJA EN EL PLANO, NO EN LA ESCENA ---
            // La línea `scene.scale.x = -1;` ha sido eliminada.

            renderer.render(scene, camera);
        }

        setupMediapipe();
    </script>
</body>
</html>
