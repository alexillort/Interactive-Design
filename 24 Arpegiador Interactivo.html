<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Arpegiador Interactivo (Corregido)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #input_video { display: none; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            width: calc(100% - 40px);
            color: white;
            font-family: monospace;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">Haz clic para iniciar la melodía</div>
    <video id="input_video" autoplay playsinline></video>
    <div id="container"></div>

    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.164.1/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const WRIST = 0, THUMB_TIP = 4, INDEX_TIP = 8;
        
        const INITIAL_VISIBLE_LANDMARKS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
        let showAllPoints = false;

        let audioContext, oscillator, masterGain, audioInitialized = false;
        let handLandmarker, scene, camera, renderer, videoTexture, backgroundPlane;
        let handPointGroups = [];
        const video = document.getElementById("input_video");
        const container = document.getElementById("container");
        const infoDiv = document.getElementById("info");

        let arpeggiatorInterval;
        let currentNoteIndex = 0;
        let arpeggioSpeed = 150;
        const scaleFrequencies = [
            220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 
            587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51, 1567.98
        ];
        let baseNoteFrequency = scaleFrequencies[0];
        let volumeLine = null;
        let volumeMidPoint = null;

        function setupWebAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            oscillator = audioContext.createOscillator();
            masterGain = audioContext.createGain();
            const reverb = audioContext.createConvolver();
            oscillator.type = 'sine';
            oscillator.connect(masterGain);
            masterGain.connect(reverb);
            reverb.connect(audioContext.destination);
            const impulseLength = 2.5;
            const impulseBuffer = audioContext.createBuffer(2, audioContext.sampleRate * impulseLength, audioContext.sampleRate);
            for (let i = 0; i < 2; i++) {
                const ch = impulseBuffer.getChannelData(i);
                for (let j = 0; j < ch.length; j++) {
                    ch[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / ch.length, 3);
                }
            }
            reverb.buffer = impulseBuffer;
            masterGain.gain.setValueAtTime(0, audioContext.currentTime);
            oscillator.start();
            audioInitialized = true;
            infoDiv.textContent = "Haz clic para mostrar todos los puntos";
            startArpeggiator();
        }

        function playArpeggioNote() {
            if (masterGain.gain.value <= 0.001) {
                masterGain.gain.cancelScheduledValues(audioContext.currentTime);
                masterGain.gain.setValueAtTime(0, audioContext.currentTime);
                return;
            };
            const pattern = [0, 2, 4, 7]; 
            const scaleIndex = scaleFrequencies.indexOf(baseNoteFrequency);
            if (scaleIndex === -1) return;
            const noteIndexInPattern = pattern[currentNoteIndex % pattern.length];
            const actualScaleIndex = (scaleIndex + noteIndexInPattern) % scaleFrequencies.length; 
            const freq = scaleFrequencies[actualScaleIndex];
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            masterGain.gain.cancelScheduledValues(audioContext.currentTime);
            masterGain.gain.setValueAtTime(masterGain.gain.value, audioContext.currentTime);
            masterGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + (arpeggioSpeed / 1000) * 0.9);
            currentNoteIndex++;
        }

        function startArpeggiator() {
            if (arpeggiatorInterval) clearInterval(arpeggiatorInterval);
            arpeggiatorInterval = setInterval(playArpeggioNote, arpeggioSpeed);
        }

        function updateArpeggiatorSpeed(speed) {
            if (Math.abs(arpeggioSpeed - speed) > 10) {
                arpeggioSpeed = speed;
                startArpeggiator();
            }
        }
        
        document.body.addEventListener('click', () => { 
            if (!audioInitialized) setupWebAudio();
            if (!showAllPoints) {
                showAllPoints = true;
                infoDiv.textContent = "Interactúa con tus manos";
            }
        });

        async function setupMediapipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    video.width = video.videoWidth;
                    video.height = video.videoHeight;
                    setupThreeJS();
                    animate();
                });
            });
        }

        function setupThreeJS() {
            scene = new THREE.Scene();
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2; 
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 100);
            camera.position.z = 1;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            videoTexture = new THREE.VideoTexture(video);
            const backgroundPlaneGeo = new THREE.PlaneGeometry(1, 1);
            const backgroundPlaneMat = new THREE.MeshBasicMaterial({ map: videoTexture });
            backgroundPlane = new THREE.Mesh(backgroundPlaneGeo, backgroundPlaneMat);
            backgroundPlane.position.z = -1;
            scene.add(backgroundPlane);

            for (let i = 0; i < 2; i++) {
                const group = new THREE.Group();
                scene.add(group);
                handPointGroups.push(group);
            }

            const lineGeometry = new THREE.BufferGeometry();
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2, transparent: true, opacity: 0.7 });
            volumeLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(volumeLine);

            const midPointGeometry = new THREE.SphereGeometry(0.01, 16, 16);
            const midPointMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9 });
            volumeMidPoint = new THREE.Mesh(midPointGeometry, midPointMaterial);
            scene.add(volumeMidPoint);
            volumeMidPoint.visible = false;

            window.addEventListener('resize', onWindowResize);
            onWindowResize();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (backgroundPlane) {
                const viewHeight = camera.top - camera.bottom;
                const viewWidth = camera.right - camera.left;
                const videoAspect = video.videoWidth / video.videoHeight;
                const viewAspect = viewWidth / viewHeight;
                let planeWidth, planeHeight;
                if (videoAspect > viewAspect) {
                    planeHeight = viewHeight;
                    planeWidth = viewHeight * videoAspect;
                } else {
                    planeWidth = viewWidth;
                    planeHeight = viewWidth / videoAspect;
                }
                backgroundPlane.scale.set(planeWidth, planeHeight, 1);
            }
        }

        // --- FUNCIÓN CORREGIDA para usar la información de "handedness" ---
        function updateHandControls(results) {
            let volume = 0;
            let speed = 250;
            
            let rightHand = null;
            let leftHand = null;

            // Identificación robusta de manos
            if (results.handedness && results.handedness.length > 0) {
                results.handedness.forEach((hand, index) => {
                    if (hand[0].categoryName === 'Right') {
                        rightHand = results.landmarks[index];
                    } else if (hand[0].categoryName === 'Left') {
                        leftHand = results.landmarks[index];
                    }
                });
            }

            if (rightHand) {
                const wristX = 1 - rightHand[0].x;
                const noteIndex = Math.floor(wristX * scaleFrequencies.length);
                baseNoteFrequency = scaleFrequencies[Math.max(0, Math.min(scaleFrequencies.length - 1, noteIndex))];
            }

            if (leftHand) {
                const wrist = leftHand[WRIST];
                speed = 300 - ((1 - wrist.y) * 250);
                
                const thumbTip = leftHand[THUMB_TIP];
                const indexTip = leftHand[INDEX_TIP];
                const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const minPinch = 0.03, maxPinch = 0.20;
                volume = Math.max(0, Math.min(1, (distance - minPinch) / (maxPinch - minPinch))) * 0.7;

                if (volumeLine && volumeMidPoint) {
                    const worldWidth = backgroundPlane.scale.x;
                    const worldHeight = backgroundPlane.scale.y;
                    const p1 = new THREE.Vector3((indexTip.x - 0.5) * worldWidth, -(indexTip.y - 0.5) * worldHeight, 0);
                    const p2 = new THREE.Vector3((thumbTip.x - 0.5) * worldWidth, -(thumbTip.y - 0.5) * worldHeight, 0);
                    volumeLine.geometry.setFromPoints([p1, p2]);
                    volumeLine.visible = true;
                    volumeLine.material.opacity = 0.3 + (volume * 0.7); 
                    volumeMidPoint.position.set((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, 0);
                    volumeMidPoint.visible = true;
                    volumeMidPoint.scale.setScalar((0.01 + (volume * 0.02)) / 0.01);
                    volumeMidPoint.material.opacity = 0.5 + (volume * 0.5);
                }
            } else {
                if (volumeLine) volumeLine.visible = false;
                if (volumeMidPoint) volumeMidPoint.visible = false;
            }

            if (audioInitialized) {
                masterGain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.05);
                updateArpeggiatorSpeed(speed);
                infoDiv.textContent = `Nota: ${baseNoteFrequency.toFixed(0)} Hz | Ritmo: ${((300 - speed)/250*100).toFixed(0)}% | Vol: ${(volume / 0.7 * 100).toFixed(0)}%`;
            }
        }
        
        // --- FUNCIÓN CORREGIDA para usar la información de "handedness" ---
        function updateHandPoints(results) {
            if (!backgroundPlane || !results.landmarks) return;
            
            const landmarks = results.landmarks;
            const handedness = results.handedness;

            landmarks.forEach((handLandmarks, handIndex) => {
                const handGroup = handPointGroups[handIndex];
                while(handGroup.children.length) handGroup.remove(handGroup.children[0]);
                
                const handType = handedness[handIndex] && handedness[handIndex][0] ? handedness[handIndex][0].categoryName : null;
                if (!handType) return; // Si no se puede determinar la mano, no dibujar

                const worldWidth = backgroundPlane.scale.x;
                const worldHeight = backgroundPlane.scale.y;

                for (let i = 0; i < handLandmarks.length; i++) {
                    if (showAllPoints || INITIAL_VISIBLE_LANDMARKS.includes(i)) {
                        const landmark = handLandmarks[i];
                        const x = (landmark.x - 0.5) * worldWidth;
                        const y = -(landmark.y - 0.5) * worldHeight;
                        const z = 0;

                        let pointSize = 0.01;
                        let pointColor = 0x99ccff;

                        if (handType === 'Right' && (i === THUMB_TIP || i === INDEX_TIP)) {
                             pointSize = 0.025; pointColor = 0x00ff00;
                        } else if (handType === 'Left' && (i === THUMB_TIP || i === INDEX_TIP)) {
                            pointSize = 0.025; pointColor = 0x00ff00;
                        } else if (handType === 'Right' && i === WRIST) {
                            pointSize = 0.03;
                            const noteNormalized = scaleFrequencies.indexOf(baseNoteFrequency) / (scaleFrequencies.length -1);
                            pointColor = new THREE.Color().setHSL(noteNormalized * 0.3 + 0.6, 1.0, 0.7).getHex();
                        } else if (handType === 'Left' && i === WRIST) { 
                            pointSize = 0.03;
                            const speedNormalized = 1 - ((arpeggioSpeed - 50) / 250);
                            pointColor = new THREE.Color().setHSL(0.6 - (speedNormalized * 0.6), 1.0, 0.7).getHex();
                        }
                        
                        const geometry = new THREE.SphereGeometry(pointSize, 16, 16);
                        const material = new THREE.MeshBasicMaterial({ color: pointColor, transparent: true, opacity: 0.8 });
                        const pointMesh = new THREE.Mesh(geometry, material);
                        pointMesh.position.set(x, y, z);
                        handGroup.add(pointMesh);
                    }
                }
            });
            for (let i = landmarks.length; i < 2; i++) {
                const handGroup = handPointGroups[i];
                while(handGroup.children.length > 0) handGroup.remove(handGroup.children[0]);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (handLandmarker && video.readyState >= 4) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                // Pasamos el objeto "results" completo a las funciones
                updateHandControls(results);
                updateHandPoints(results);
            }
            scene.scale.x = -1;
            renderer.render(scene, camera);
        }

        setupMediapipe();
    </script>
</body>
</html>
