<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Arpegiador Interactivo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #input_video { display: none; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            width: calc(100% - 40px);
            color: white;
            font-family: monospace;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">Haz clic para iniciar la melodía</div>
    <video id="input_video" autoplay playsinline></video>
    <div id="container"></div>

    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.164.1/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        // Puntas de los dedos y muñeca: Pulgar(4), Índice(8), Muñeca(0)
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const WRIST = 0; // Punto de la muñeca

        let audioContext, oscillator, masterGain, audioInitialized = false;
        let handLandmarker, scene, camera, renderer, videoTexture, backgroundPlane;
        let handPointGroups = [];
        const video = document.getElementById("input_video");
        const container = document.getElementById("container");
        const infoDiv = document.getElementById("info");

        let arpeggiatorInterval;
        let currentNoteIndex = 0;
        let arpeggioSpeed = 150;
        const scaleFrequencies = [
            220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 
            587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51, 1567.98
        ];
        let baseNoteFrequency = scaleFrequencies[0];

        // --- (NUEVO) Línea y punto medio para el volumen ---
        let volumeLine = null;
        let volumeMidPoint = null;

        function setupWebAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            oscillator = audioContext.createOscillator();
            masterGain = audioContext.createGain();
            const reverb = audioContext.createConvolver();
            oscillator.type = 'sine';
            oscillator.connect(masterGain);
            masterGain.connect(reverb);
            reverb.connect(audioContext.destination);
            const impulseLength = 2.5;
            const impulseBuffer = audioContext.createBuffer(2, audioContext.sampleRate * impulseLength, audioContext.sampleRate);
            for (let i = 0; i < 2; i++) {
                const ch = impulseBuffer.getChannelData(i);
                for (let j = 0; j < ch.length; j++) {
                    ch[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / ch.length, 3);
                }
            }
            reverb.buffer = impulseBuffer;
            masterGain.gain.setValueAtTime(0, audioContext.currentTime);
            oscillator.start();
            audioInitialized = true;
            infoDiv.textContent = "Haz clic e interactúa con tus manos";
            startArpeggiator();
        }

        function playArpeggioNote() {
            if (masterGain.gain.value <= 0.001) {
                masterGain.gain.cancelScheduledValues(audioContext.currentTime);
                masterGain.gain.setValueAtTime(0, audioContext.currentTime);
                return;
            };

            const pattern = [0, 2, 4, 1]; // Tónica, Tercera Mayor, Quinta Perfecta, Octava (para un arpegio más completo)
            const scaleIndex = scaleFrequencies.indexOf(baseNoteFrequency);
            if (scaleIndex === -1) return; // Si la baseNoteFrequency no está en la escala, salir
            
            // Asegurarse de que el índice no exceda el tamaño del patrón o de la escala
            const noteIndexInPattern = pattern[currentNoteIndex % pattern.length];
            const actualScaleIndex = (scaleIndex + noteIndexInPattern) % scaleFrequencies.length; 
            const freq = scaleFrequencies[actualScaleIndex];

            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            masterGain.gain.cancelScheduledValues(audioContext.currentTime);
            masterGain.gain.setValueAtTime(masterGain.gain.value, audioContext.currentTime);
            masterGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + (arpeggioSpeed / 1000) * 0.9);

            currentNoteIndex++;
        }

        function startArpeggiator() {
            if (arpeggiatorInterval) clearInterval(arpeggiatorInterval);
            arpeggiatorInterval = setInterval(playArpeggioNote, arpeggioSpeed);
        }

        function updateArpeggiatorSpeed(speed) {
            if (Math.abs(arpeggioSpeed - speed) > 10) {
                arpeggioSpeed = speed;
                startArpeggiator();
            }
        }
        
        document.body.addEventListener('click', () => { if (!audioInitialized) setupWebAudio(); });

        async function setupMediapipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    video.width = video.videoWidth;
                    video.height = video.videoHeight;
                    setupThreeJS();
                    animate();
                });
            });
        }

        function setupThreeJS() {
            scene = new THREE.Scene();
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2; 
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 100);
            camera.position.z = 1;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            videoTexture = new THREE.VideoTexture(video);
            const backgroundPlaneGeo = new THREE.PlaneGeometry(1, 1);
            const backgroundPlaneMat = new THREE.MeshBasicMaterial({ map: videoTexture });
            backgroundPlane = new THREE.Mesh(backgroundPlaneGeo, backgroundPlaneMat);
            backgroundPlane.position.z = -1;
            scene.add(backgroundPlane);

            for (let i = 0; i < 2; i++) {
                const group = new THREE.Group();
                scene.add(group);
                handPointGroups.push(group);
            }

            // --- (NUEVO) Inicializar la línea de volumen y el punto medio ---
            const lineGeometry = new THREE.BufferGeometry();
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2, transparent: true, opacity: 0.7 });
            volumeLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(volumeLine);

            const midPointGeometry = new THREE.SphereGeometry(0.01, 16, 16);
            const midPointMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9 });
            volumeMidPoint = new THREE.Mesh(midPointGeometry, midPointMaterial);
            scene.add(volumeMidPoint);
            volumeMidPoint.visible = false; // Ocultar al inicio

            window.addEventListener('resize', onWindowResize);
            onWindowResize();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (backgroundPlane) {
                const viewHeight = camera.top - camera.bottom;
                const viewWidth = camera.right - camera.left;
                const videoAspect = video.videoWidth / video.videoHeight;
                const viewAspect = viewWidth / viewHeight;
                let planeWidth, planeHeight;
                if (videoAspect > viewAspect) {
                    planeHeight = viewHeight;
                    planeWidth = viewHeight * videoAspect;
                } else {
                    planeWidth = viewWidth;
                    planeHeight = viewWidth / videoAspect;
                }
                backgroundPlane.scale.set(planeWidth, planeHeight, 1);
            }
        }

        function updateHandControls(landmarks) {
            let volume = 0;
            let speed = 250;

            if (landmarks && landmarks.length > 0) {
                const rightHand = landmarks.find(hand => hand[0].x < 0.5);
                const leftHand = landmarks.find(hand => hand[0].x >= 0.5);

                if (rightHand) {
                    const wristX = 1 - rightHand[0].x;
                    const noteIndex = Math.floor(wristX * scaleFrequencies.length);
                    const clampedIndex = Math.max(0, Math.min(scaleFrequencies.length - 1, noteIndex));
                    baseNoteFrequency = scaleFrequencies[clampedIndex];
                }

                if (leftHand) {
                    // --- Control de velocidad con la altura (Y) de la muñeca izquierda ---
                    const wrist = leftHand[WRIST];
                    const wristY = 1 - wrist.y; // Altura de la muñeca
                    speed = 300 - (wristY * 250); // Rango de 50ms (rápido) a 300ms (lento)
                    
                    const thumbTip = leftHand[THUMB_TIP];
                    const indexTip = leftHand[INDEX_TIP];

                    // Calcular distancia 2D para el volumen
                    const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

                    const minPinch = 0.03;
                    const maxPinch = 0.20;
                    const rawVolume = (distance - minPinch) / (maxPinch - minPinch);
                    volume = Math.max(0, Math.min(1, rawVolume)) * 0.7; // Volumen máximo ajustado a 70%

                    // --- (NUEVO) Actualizar la línea de volumen y el punto medio ---
                    if (volumeLine && volumeMidPoint) {
                        const worldWidth = backgroundPlane.scale.x;
                        const worldHeight = backgroundPlane.scale.y;

                        const p1 = new THREE.Vector3(
                            (indexTip.x - 0.5) * worldWidth,
                            -(indexTip.y - 0.5) * worldHeight,
                            0
                        );
                        const p2 = new THREE.Vector3(
                            (thumbTip.x - 0.5) * worldWidth,
                            -(thumbTip.y - 0.5) * worldHeight,
                            0
                        );
                        volumeLine.geometry.setFromPoints([p1, p2]);
                        volumeLine.visible = true;

                        // Opacidad de la línea según el volumen
                        volumeLine.material.opacity = 0.3 + (volume * 0.7); 
                        
                        // Posición del punto medio
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        volumeMidPoint.position.set(midX, midY, 0);
                        volumeMidPoint.visible = true;

                        // Tamaño y color del punto medio según el volumen
                        const midPointSize = 0.01 + (volume * 0.02);
                        volumeMidPoint.scale.setScalar(midPointSize / 0.01); // Escalar en relación al tamaño base
                        volumeMidPoint.material.opacity = 0.5 + (volume * 0.5);
                    }
                } else {
                    // Si no se detecta la mano izquierda, ocultar la línea y el punto medio
                    if (volumeLine) volumeLine.visible = false;
                    if (volumeMidPoint) volumeMidPoint.visible = false;
                }
            } else {
                // Si no se detecta ninguna mano, asegurarse de que estén ocultos
                if (volumeLine) volumeLine.visible = false;
                if (volumeMidPoint) volumeMidPoint.visible = false;
            }

            if (audioInitialized) {
                masterGain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.05);
                updateArpeggiatorSpeed(speed);
                infoDiv.textContent = `Nota: ${baseNoteFrequency.toFixed(0)} Hz | Ritmo: ${((300 - speed)/250*100).toFixed(0)}% | Vol: ${(volume / 0.7 * 100).toFixed(0)}%`;
            }
        }
        
        function updateHandPoints(landmarks) {
            if (!backgroundPlane) return;
            const worldWidth = backgroundPlane.scale.x;
            const worldHeight = backgroundPlane.scale.y;

            landmarks.forEach((handLandmarks, handIndex) => {
                const handGroup = handPointGroups[handIndex];
                while(handGroup.children.length) handGroup.remove(handGroup.children[0]);
                
                // Iterar sobre todos los puntos, no solo las puntas de los dedos
                for (let i = 0; i < handLandmarks.length; i++) {
                    const landmark = handLandmarks[i];
                    const x = (landmark.x - 0.5) * worldWidth;
                    const y = -(landmark.y - 0.5) * worldHeight;
                    const z = 0;

                    let pointSize = 0.01; // Tamaño base para la mayoría de los puntos
                    let pointColor = 0x99ccff; // Color base

                    // --- (NUEVO) Agrandar y colorear puntos principales ---
                    if (handIndex === 0 && i === THUMB_TIP) { // Pulgar mano derecha (Nota)
                        pointSize = 0.03;
                        pointColor = 0xffaaff; // Magenta claro
                    } else if (handIndex === 1 && i === THUMB_TIP) { // Pulgar mano izquierda (Volumen)
                        pointSize = 0.025;
                        pointColor = 0x00ff00; // Verde
                    } else if (handIndex === 1 && i === INDEX_TIP) { // Índice mano izquierda (Volumen)
                        pointSize = 0.025;
                        pointColor = 0x00ff00; // Verde
                    } else if (handIndex === 1 && i === WRIST) { // Muñeca mano izquierda (Ritmo)
                        pointSize = 0.03;
                        // Color de la muñeca según la velocidad (azul lento -> rojo rápido)
                        const speedNormalized = 1 - ((arpeggioSpeed - 50) / 250); // 0 (lento) a 1 (rápido)
                        pointColor = new THREE.Color().setHSL(0.6 - (speedNormalized * 0.6), 1.0, 0.7).getHex();
                    }

                    const geometry = new THREE.SphereGeometry(pointSize, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color: pointColor, transparent: true, opacity: 0.8 });
                    const pointMesh = new THREE.Mesh(geometry, material);
                    pointMesh.position.set(x, y, z);
                    handGroup.add(pointMesh);
                }
            });
            for (let i = landmarks.length; i < 2; i++) {
                handPointGroups[i].children.length = 0;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (handLandmarker && video.readyState >= 4) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                updateHandControls(results.landmarks);
                updateHandPoints(results.landmarks);
            }
            scene.scale.x = -1;
            renderer.render(scene, camera);
        }

        setupMediapipe();
    </script>
</body>
</html>