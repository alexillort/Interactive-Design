<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Distorsión 2D con Círculos Perfectos</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; } /* Añadido cursor */
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #input_video { display: none; }
    </style>
</head>
<body>
    <video id="input_video" autoplay playsinline></video>
    <div id="container"></div>

    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const FINGER_TIPS = [4, 8, 12, 16, 20];

        let handLandmarker;
        let scene, camera, renderer, videoTexture, backgroundPlane;
        
        const video = document.getElementById("input_video");
        const container = document.getElementById("container");

        const ripples = [];
        const MAX_RIPPLES = 10;
        const RIPPLE_DECAY_RATE = 0.03;
        let handPointGroups = [];
        
        // --- CAMBIO 1: Variable de estado para controlar la visibilidad de los puntos ---
        let showPoints = false;

        const customUniforms = {
            u_videoTexture: { value: null },
            u_resolution: { value: new THREE.Vector2() },
            u_time: { value: 0.0 },
            u_ripples: { value: Array(MAX_RIPPLES).fill(new THREE.Vector4(0, 0, 0, 0)) },
            u_numRipples: { value: 0 }
        };

        // --- CAMBIO 2: Función para activar los puntos con un solo clic ---
        function activatePoints() {
            showPoints = true;
            window.removeEventListener('click', activatePoints);
            window.removeEventListener('touchstart', activatePoints);
            document.body.style.cursor = 'default';
        }
        window.addEventListener('click', activatePoints);
        window.addEventListener('touchstart', activatePoints);

        async function setupMediapipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    video.width = video.videoWidth;
                    video.height = video.videoHeight;
                    setupThreeJS();
                    animate();
                });
            }).catch(err => console.error("Error al acceder a la cámara:", err));
        }

        function setupThreeJS() {
            scene = new THREE.Scene();
            
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2; 
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 100);
            camera.position.z = 1;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            
            customUniforms.u_videoTexture.value = videoTexture;
            customUniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);

            const backgroundPlaneGeo = new THREE.PlaneGeometry(1, 1);
            const backgroundPlaneMat = new THREE.ShaderMaterial({
                uniforms: customUniforms,
                vertexShader: `
                    varying vec2 vUv;
                    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
                `,
                fragmentShader: `
                    uniform sampler2D u_videoTexture;
                    uniform vec2 u_resolution;
                    uniform float u_time;
                    uniform vec4 u_ripples[${MAX_RIPPLES}];
                    uniform int u_numRipples;
                    varying vec2 vUv;

                    void main() {
                        vec2 uv = vUv;
                        vec2 distortedUv = uv;
                        float aspectRatio = u_resolution.x / u_resolution.y;
                        vec2 aspectCorrection = vec2(aspectRatio, 1.0);

                        for (int i = 0; i < u_numRipples; i++) {
                            vec2 ripplePos = u_ripples[i].xy;
                            float radius = u_ripples[i].z;
                            float intensity = u_ripples[i].w;
                            vec2 diff = uv - ripplePos;
                            diff *= aspectCorrection;
                            float dist = length(diff);

                            if (dist < radius) {
                                vec2 direction = normalize(uv - ripplePos);
                                float wave = cos((dist - radius) * 25.0) * (radius - dist);
                                direction /= aspectCorrection;
                                distortedUv += direction * wave * 0.1 * intensity;
                            }
                        }
                        // La textura del video ya tiene color, por lo que el resultado será en color.
                        gl_FragColor = texture2D(u_videoTexture, distortedUv);
                    }
                `,
                transparent: true,
                depthWrite: false
            });
            backgroundPlane = new THREE.Mesh(backgroundPlaneGeo, backgroundPlaneMat);
            backgroundPlane.position.z = -1;
            scene.add(backgroundPlane);

            adjustBackgroundPlaneSize();

            for (let i = 0; i < 2; i++) {
                const group = new THREE.Group();
                scene.add(group);
                handPointGroups.push(group);
            }

            window.addEventListener('resize', onWindowResize);
        }

        function adjustBackgroundPlaneSize() {
            if (!video.videoWidth || !video.videoHeight || !backgroundPlane) return;
            
            const viewHeight = camera.top - camera.bottom;
            const viewWidth = camera.right - camera.left;
            const videoAspect = video.videoWidth / video.videoHeight;
            const viewAspect = viewWidth / viewHeight;
            
            let planeWidth, planeHeight;
            if (videoAspect > viewAspect) {
                planeHeight = viewHeight;
                planeWidth = viewHeight * videoAspect;
            } else {
                planeWidth = viewWidth;
                planeHeight = viewWidth / videoAspect;
            }
            backgroundPlane.scale.set(planeWidth, planeHeight, 1);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            customUniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
            adjustBackgroundPlaneSize();
        }
        
        let lastFingerTipPositions = new Map();

        function updateRipples(landmarks) {
            const newFingerTipPositions = new Map();
            if (landmarks && landmarks.length > 0) {
                landmarks.forEach((handLandmarks, handIdx) => {
                    FINGER_TIPS.forEach(tipIndex => {
                        const landmark = handLandmarks[tipIndex];
                        const x = landmark.x;
                        const y = 1.0 - landmark.y;
                        const fingerId = `${handIdx}_${tipIndex}`;
                        newFingerTipPositions.set(fingerId, new THREE.Vector2(x, y));
                        if (lastFingerTipPositions.has(fingerId)) {
                            const lastPos = lastFingerTipPositions.get(fingerId);
                            if (lastPos.distanceTo(new THREE.Vector2(x, y)) > 0.02) {
                                ripples.push({ position: new THREE.Vector2(x, y), radius: 0.0, intensity: 1.0 });
                                if (ripples.length > MAX_RIPPLES) ripples.shift();
                            }
                        }
                    });
                });
            }
            lastFingerTipPositions = newFingerTipPositions;
            for (let i = ripples.length - 1; i >= 0; i--) {
                const ripple = ripples[i];
                ripple.radius += 0.015;
                ripple.intensity -= RIPPLE_DECAY_RATE;
                if (ripple.intensity <= 0) ripples.splice(i, 1);
            }
            customUniforms.u_numRipples.value = ripples.length;
            for (let i = 0; i < MAX_RIPPLES; i++) {
                if (i < ripples.length) {
                    const r = ripples[i];
                    customUniforms.u_ripples.value[i].set(r.position.x, r.position.y, r.radius, r.intensity);
                } else {
                    customUniforms.u_ripples.value[i].set(0, 0, 0, 0);
                }
            }
        }

        function updateHandPoints(landmarks) {
            const worldPlaneWidth = backgroundPlane.scale.x;
            const worldPlaneHeight = backgroundPlane.scale.y;

            landmarks.forEach((handLandmarks, index) => {
                const handGroup = handPointGroups[index];
                while(handGroup.children.length) handGroup.remove(handGroup.children[0]);
                
                FINGER_TIPS.forEach(tipIndex => {
                    const landmark = handLandmarks[tipIndex];
                    const x = (landmark.x - 0.5) * worldPlaneWidth;
                    const y = -(landmark.y - 0.5) * worldPlaneHeight;
                    const z = 0;

                    const geometry = new THREE.SphereGeometry(0.02, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(tipIndex / FINGER_TIPS.length, 1.0, 0.5) });
                    const pointMesh = new THREE.Mesh(geometry, material);
                    pointMesh.position.set(x, y, z);
                    handGroup.add(pointMesh);
                });
            });
            
            // Limpia los puntos de las manos que no se detectan
            for (let i = landmarks.length; i < 2; i++) {
                 while(handPointGroups[i].children.length) handPointGroups[i].remove(handPointGroups[i].children[0]);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            customUniforms.u_time.value += 0.01;

            if (handLandmarker && video.readyState >= 4) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                updateRipples(results.landmarks);

                // --- CAMBIO 3: Llamada condicional para dibujar los puntos ---
                if (showPoints) {
                    updateHandPoints(results.landmarks);
                } else {
                    // Si no se deben mostrar, nos aseguramos de que los grupos estén vacíos
                    handPointGroups.forEach(group => {
                         while(group.children.length) group.remove(group.children[0]);
                    });
                }
            }
            
            scene.scale.x = -1;
            renderer.render(scene, camera);
        }

        setupMediapipe();
    </script>
</body>
</html>
